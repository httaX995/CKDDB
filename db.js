



/*








Didula MD



â „â „â „â¢°â£§â£¼â£¯â „â£¸â£ â£¶â£¶â£¦â£¾â „â „â „â „â¡€â „â¢€â£¿â£¿â „â „â „â¢¸â¡‡â „â „
â „â „â „â£¾â£¿â ¿â ¿â ¶â ¿â¢¿â£¿â£¿â£¿â£¿â£¦â£¤â£„â¢€â¡…â¢ â£¾â£›â¡‰â „â „â „â ¸â¢€â£¿â „
â „â „â¢€â¡‹â£¡â£´â£¶â£¶â¡€â „â „â ™â¢¿â£¿â£¿â£¿â£¿â£¿â£´â£¿â£¿â£¿â¢ƒâ£¤â£„â£€â£¥â£¿â£¿â „
â „â „â¢¸â£‡â »â£¿â£¿â£¿â£§â£€â¢€â£ â¡Œâ¢»â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ¿â ¿â ¿â£¿â£¿â£¿â „
â „â¢€â¢¸â£¿â£·â£¤â£¤â£¤â£¬â£™â£›â¢¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â£¿â£¿â¡â „â „â¢€â£¤â£„â ‰â ‹â£°
â „â£¼â£–â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¢¿â£¿â£¿â£¿â£¿â£¿â¢‡â£¿â£¿â¡·â ¶â ¶â¢¿â£¿â£¿â ‡â¢€â£¤
â ˜â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£½â£¿â£¿â£¿â¡‡â£¿â£¿â£¿â£¿â£¿â£¿â£·â£¶â£¥â£´â£¿â¡—
â¢€â ˆâ¢¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡Ÿâ „
â¢¸â£¿â£¦â£Œâ£›â£»â£¿â£¿â£§â ™â ›â ›â¡­â …â ’â ¦â ­â£­â¡»â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â ƒâ „
â ˜â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡†â „â „â „â „â „â „â „â „â ¹â ˆâ¢‹â£½â£¿â£¿â£¿â£¿â£µâ£¾â ƒâ „
â „â ˜â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â „â£´â£¿â£¶â£„â „â£´â£¶â „â¢€â£¾â£¿â£¿â£¿â£¿â£¿â£¿â ƒâ „â „
â „â „â ˆâ »â£¿â£¿â£¿â£¿â£¿â£¿â¡„â¢»â£¿â£¿â£¿â „â£¿â£¿â¡€â£¾â£¿â£¿â£¿â£¿â£›â ›â â „â „â „
â „â „â „â „â ˆâ ›â¢¿â£¿â£¿â£¿â â â¢¿â£¿â£¿â¡„â¢¿â£¿â¡‡â£¸â£¿â£¿â ¿â ›â â „â „â „â „â „
â „â „â „â „â „â „â „â ‰â »â£¿â£¿â£¾â£¦â¡™â »â£·â£¾â£¿â ƒâ ¿â ‹â â „â „â „â „â „â¢€â£ â£´
â£¿â£¿â£¿â£¶â£¶â£®â£¥â£’â ²â¢®â£â¡¿â£¿â£¿â¡†â£¿â¡¿â ƒâ „â „â „â „â „â „â „â£ â£´â£¿â£¿â£¿

Ì¶ Ì¶ Ì¶ÍÍŸ Ì¶ÍÍŸ Ì¶ÍÍŸ Ì¶ğŸƒ:ğ—œ ğ—™ğ—¨ğ—–ğ—ğ£ğ—— ğ—¬ğ§ğ—¨ğ—¥ ğ——ğ£ğ—©ğ—œğ—–ğ£:|ğŸƒ ÍÍŸ

===============

Didula Rashmika 




*/













































// =============================================================









const { cmd, commands } = require('../lib/command');
const scraper = require("../lib/scraperd");
const axios = require('axios');
const fetch = require('node-fetch');
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')
var { updateCMDStore,isbtnID,getCMDStore,getCmdForCmdId,connectdb,input,get,updb,updfb } = require("../lib/database")

var { get_set , input_set } = require('../lib/set_db')        
// ======================âœ…ğŸ’—

const { lookup } = require('mime-types');
const fs = require('fs');
const path = require('path');
const yts = require('yt-search'); // For YouTube search
const cheerio = require('cheerio'); // Import cheerio for HTML parsing

const { ytsearch, ytmp3, ytmp4 } = require('@dark-yasiya/yt-dl.js'); 
const config = require('../settings')
const xml2js = require('xml2js');
const { updateEnv, readEnv } = require('../lib/database');
const os = require("os")
// ğŸ˜‚ğŸŒà¶†à¶† à·„à¶¸à·Šà¶¶à·”à¶±à·Šà¶¯à· ğŸ˜ğŸ˜ğŸ˜ğŸ˜
// ğŸŒà¶½à·ƒà·Šà·ƒà¶±à¶ºà·’ à¶½à·ƒà·Šà·ƒà¶±à¶ºà·’ ğŸŒ
const { BufferJSON, WA_DEFAULT_EPHEMERAL, generateWAMessageFromContent, proto, generateWAMessageContent, generateWAMessage, prepareWAMessageMedia, downloadContentFromMessage, areJidsSameUser, getContentType } = require('@whiskeysockets/baileys')
const { igdl } = require('ruhend-scraper');

const si = require('systeminformation');
const pdfUrl = "https://i.ibb.co/tC37Q7B/20241220-122443.jpg";
const g_i_s = require('g-i-s');
let { img2url } = require('@blackamda/telegram-image-url');

const {Sticker, createSticker, StickerTypes} = require("wa-sticker-formatter");
// ============== à¶†à¶­à¶½à·Š à·„à·”à¶­à·Šà¶­à· ğŸŒğŸ˜‚




/*

â „â „â „â¢°â£§â£¼â£¯â „â£¸â£ â£¶â£¶â£¦â£¾â „â „â „â „â¡€â „â¢€â£¿â£¿â „â „â „â¢¸â¡‡â „â „
â „â „â „â£¾â£¿â ¿â ¿â ¶â ¿â¢¿â£¿â£¿â£¿â£¿â£¦â£¤â£„â¢€â¡…â¢ â£¾â£›â¡‰â „â „â „â ¸â¢€â£¿â „
â „â „â¢€â¡‹â£¡â£´â£¶â£¶â¡€â „â „â ™â¢¿â£¿â£¿â£¿â£¿â£¿â£´â£¿â£¿â£¿â¢ƒâ£¤â£„â£€â£¥â£¿â£¿â „
â „â „â¢¸â£‡â »â£¿â£¿â£¿â£§â£€â¢€â£ â¡Œâ¢»â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ¿â ¿â ¿â£¿â£¿â£¿â „
â „â¢€â¢¸â£¿â£·â£¤â£¤â£¤â£¬â£™â£›â¢¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â£¿â£¿â¡â „â „â¢€â£¤â£„â ‰â ‹â£°
â „â£¼â£–â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¢¿â£¿â£¿â£¿â£¿â£¿â¢‡â£¿â£¿â¡·â ¶â ¶â¢¿â£¿â£¿â ‡â¢€â£¤
â ˜â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£½â£¿â£¿â£¿â¡‡â£¿â£¿â£¿â£¿â£¿â£¿â£·â£¶â£¥â£´â£¿â¡—
â¢€â ˆâ¢¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡Ÿâ „
â¢¸â£¿â£¦â£Œâ£›â£»â£¿â£¿â£§â ™â ›â ›â¡­â …â ’â ¦â ­â£­â¡»â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â ƒâ „
â ˜â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡†â „â „â „â „â „â „â „â „â ¹â ˆâ¢‹â£½â£¿â£¿â£¿â£¿â£µâ£¾â ƒâ „
â „â ˜â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â „â£´â£¿â£¶â£„â „â£´â£¶â „â¢€â£¾â£¿â£¿â£¿â£¿â£¿â£¿â ƒâ „â „
â „â „â ˆâ »â£¿â£¿â£¿â£¿â£¿â£¿â¡„â¢»â£¿â£¿â£¿â „â£¿â£¿â¡€â£¾â£¿â£¿â£¿â£¿â£›â ›â â „â „â „
â „â „â „â „â ˆâ ›â¢¿â£¿â£¿â£¿â â â¢¿â£¿â£¿â¡„â¢¿â£¿â¡‡â£¸â£¿â£¿â ¿â ›â â „â „â „â „â „
â „â „â „â „â „â „â „â ‰â »â£¿â£¿â£¾â£¦â¡™â »â£·â£¾â£¿â ƒâ ¿â ‹â â „â „â „â „â „â¢€â£ â£´
â£¿â£¿â£¿â£¶â£¶â£®â£¥â£’â ²â¢®â£â¡¿â£¿â£¿â¡†â£¿â¡¿â ƒâ „â „â „â „â „â „â „â£ â£´â£¿â£¿â£¿

Ì¶ Ì¶ Ì¶ÍÍŸ Ì¶ÍÍŸ Ì¶ÍÍŸ Ì¶ğŸƒ:ğ—œ ğ—™ğ—¨ğ—–ğ—ğ£ğ—— ğ—¬ğ§ğ—¨ğ—¥ ğ——ğ£ğ—©ğ—œğ—–ğ£:|ğŸƒ ÍÍŸ


*/

//  ===================  Didula MD Fuck Imdex ==============



cmd({
    on: "body"
}, async (conn, mek, m, { from, body, isGroup, isAdmins, isBotAdmins, reply, sender }) => {
    try {
        // Auto Bio Update
        if (config.AUTO_BIO === 'true') {
            const bioText = `ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸ ğ‘ğ®ğ§ğ§ğ¢ğ§ğ  ğ’ğ¦ğ¨ğ¨ğ­ğ¡ğ¥ğ²...`;
            await conn.updateProfileStatus(bioText);
        }

        // Auto Typing Status
        if (config.AUTO_TYPING === 'true') {
            await conn.sendPresenceUpdate('composing', mek.key.remoteJid);
        }

        // Recording Status
        if (config.RECORDING === 'true') {
            await conn.sendPresenceUpdate('recording', mek.key.remoteJid);
        }

        // Online Status
        if (config.ALWAYS_ONLINE === 'true') {
            await conn.sendPresenceUpdate('available', mek.key.remoteJid);
        } else {
            await conn.sendPresenceUpdate('unavailable', mek.key.remoteJid);
        }

    } catch (error) {
        console.error("Error processing message:", error);
        reply("An error occurred while processing your message. Please try again later.");
    }
});











//   ================== convert category plugin====================
const googleTTS = require('google-tts-api')

cmd({
    pattern: "tts",
    desc: "Text-to-speech",
    category: "convert",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {


if(!q) return reply("*_Please give me a text._*")

const url = googleTTS.getAudioUrl(q, {
  lang: 'en',
  slow: false,
  host: 'https://translate.google.com',
});

await conn.sendMessage(from,{audio: {url: url },mimetype:"audio/mpeg"},{quoted:mek})
        
}catch(e){
console.log(e)
reply(`${e}`)

}
})



cmd({
    pattern: "readmore",
    desc: "Readmore message",
    category: "convert",
    react: "ğŸ“",
    filename: __filename
}, async (conn, mek, m, {
    from, quoted, body, isCmd, command, args, q, isGroup, sender
}) => {
    try {
        // Get the message text after the command (.readmore text)
        let readmoreText = q ? q : "No text provided";

        // Create the "Readmore" effect by adding a special character to split the text
        let readmore = "\u200B".repeat(4000); // This creates a large gap between text

        // Full message to send
        let replyText = `Didula MD V2\n\n${readmore}${readmoreText}`;

        // Send the message with the "Readmore" functionality
        await conn.sendMessage(from, { text: replyText }, { quoted: mek });

        // React to the message
        await conn.sendMessage(from, { react: { text: "", key: mek.key } });

    } catch (e) {
        console.log(e);
        reply(`Error: ${e.message}`);
    }
});




cmd({
    pattern: "convert",
    desc: "Convert an amount from one currency to another.",
    category: "convert",
    react: "ğŸ’±",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (args.length < 3) {
            return reply("Usage: .convert <amount> <from_currency> <to_currency>");
        }

        const amount = args[0];
        const fromCurrency = args[1].toUpperCase();
        const toCurrency = args[2].toUpperCase();

        if (isNaN(amount)) {
            return reply("Please provide a valid amount.");
        }

        const apiUrl = `https://api.exchangerate-api.com/v4/latest/${fromCurrency}`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        if (!data.rates[toCurrency]) {
            return reply(`Conversion rate for ${toCurrency} not found.`);
        }

        const convertedAmount = (amount * data.rates[toCurrency]).toFixed(2);
        let conversionInfo = `ğŸ’¸_*Currency Conversion*_ğŸ’¸\n\n`;
        conversionInfo += `ğŸ’µ *Amount*: ${amount} ${fromCurrency}\n`;
        conversionInfo += `ğŸ”„ *Converted Amount*: ${convertedAmount} ${toCurrency}\n`;
        conversionInfo += `ğŸ“ˆ *Exchange Rate*: 1 ${fromCurrency} = ${data.rates[toCurrency]} ${toCurrency}\n
        
> ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ
        `;

        await conn.sendMessage(from, { text: conversionInfo }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`Error fetching data: ${e.message}`);
    }
});








const { image2url } = require('@dark-yasiya/imgbb.js')

cmd({
    pattern: "img2url",
    desc: "Image convert to url",
    category: "convert",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{




    const isQuotedImage = m.quoted ? ((m.quoted.type === 'imageMessage') || (isQuotedViewOnce ? (m.quoted.msg.type === 'imageMessage') : false)) : false

     if ((m.type === 'imageMessage') || isQuotedImage) {
      var nameJpg = `didulamd`
      isQuotedImage ? await m.quoted.download(nameJpg) : await m.download(nameJpg)

let data = await image2url(nameJpg + '.jpg');

let msg = `*Url :* ${data.result.url}

> ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ`

reply(`${msg}`)
     } else {
reply("*_Please reply an image._*")
     }
}catch(e){
console.log(e)
reply(`${e}`)
}
})









var imgmsg =''
if(config.LANG === 'SI') imgmsg = '*à·ƒà·Šà¶§à·’à¶šà¶»à¶ºà¶šà¶§ mention à¶¯à·™à¶±à·Šà¶± !*'
else imgmsg = "*Reply to a sticker !*"
var descg = ''
if(config.LANG === 'SI') descg = "à¶‘à¶º à¶”à¶¶à¶œà·š mention à¶¯à·”à¶±à·Š sticker img à¶¶à·€à¶§ à¶´à¶»à·’à·€à¶»à·Šà¶­à¶±à¶º à¶šà¶»à¶ºà·’."
else descg = "It converts your replied sticker to img."

cmd({
    pattern: "toimg",
    react: "ğŸ”®",
    alias: ["s","stic"],
    desc: descg,
    category: "convert",
    use: '.sticker <Reply to image>',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    const isQuotedViewOnce = m.quoted ? (m.quoted.type === 'viewOnceMessage') : false
    const isQuotedImage = m.quoted ? ((m.quoted.type === 'imageMessage') || (isQuotedViewOnce ? (m.quoted.msg.type === 'imageMessage') : false)) : false
    const isQuotedVideo = m.quoted ? ((m.quoted.type === 'videoMessage') || (isQuotedViewOnce ? (m.quoted.msg.type === 'videoMessage') : false)) : false
    const isQuotedSticker = m.quoted ? (m.quoted.type === 'stickerMessage') : false
if ( isQuotedSticker ) { 

var nameJpg = getRandom('');
let buff = isQuotedSticker ? await m.quoted.download(nameJpg) : await m.download(nameJpg)
let type = await fileType.fromBuffer(buff);
await fs.promises.writeFile("./" + type.ext, buff);  
await conn.sendMessage(from, { image: fs.readFileSync("./" + type.ext), caption: config.FOOTER }, { quoted: mek })

}else return await  reply(imgmsg)
} catch (e) {
reply('*Error !!*')
l(e)
}
})



cmd({
    pattern: "sticker",
    react: "ğŸ”®",
    alias: ["s","stic"],

    category: "convert",
    use: '.sticker <Reply to image>',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    const isQuotedViewOnce = m.quoted ? (m.quoted.type === 'viewOnceMessage') : false
    const isQuotedImage = m.quoted ? ((m.quoted.type === 'imageMessage') || (isQuotedViewOnce ? (m.quoted.msg.type === 'imageMessage') : false)) : false
    const isQuotedVideo = m.quoted ? ((m.quoted.type === 'videoMessage') || (isQuotedViewOnce ? (m.quoted.msg.type === 'videoMessage') : false)) : false
    const isQuotedSticker = m.quoted ? (m.quoted.type === 'stickerMessage') : false
     if ((m.type === 'imageMessage') || isQuotedImage) {
      var nameJpg = getRandom('')
      isQuotedImage ? await m.quoted.download(nameJpg) : await m.download(nameJpg)
    let sticker = new Sticker(nameJpg + '.jpg', {
    pack: 'Didula Md', // The pack name
    author: 'Didula Rashmika', // The author name
      type: q.includes("--crop" || '-c') ? StickerTypes.CROPPED : StickerTypes.FULL,
      categories: ["ğŸ¤©", "ğŸ‰"], // The sticker category
      id: "12345", // The sticker id
      quality: 75, // The quality of the output file
      background: "transparent", // The sticker background color (only for full stickers)
  });
  const buffer = await sticker.toBuffer();
  return conn.sendMessage(from, {sticker: buffer}, {quoted: mek })
}  else if ( isQuotedSticker ) { 

    var nameWebp = getRandom('')
    await m.quoted.download(nameWebp)
  let sticker = new Sticker(nameWebp + '.webp', {
    pack: 'Didula Md', // The pack name
    author: 'Didula Rashmika', // The author name
    type: q.includes("--crop" || '-c') ? StickerTypes.CROPPED : StickerTypes.FULL,
    categories: ["ğŸ¤©", "ğŸ‰"], // The sticker category
    id: "12345", // The sticker id
    quality: 75, // The quality of the output file
    background: "transparent", // The sticker background color (only for full stickers)
});
const buffer = await sticker.toBuffer();
return conn.sendMessage(from, {sticker: buffer}, {quoted: mek })
}else return await  reply(imgmsg)
} catch (e) {
    reply('Error !!')
    console.log(e)
}
})









// Logo List Command
cmd({
    pattern: "logolist",
    desc: "Create logos",
    category: "convert",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if(!q) return reply("*_Please give me a text._*")

        let logoMsg = `*_Didula MD V2 ğŸ’š LOGO MAKER_*

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
*Text :* ${q}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

_ğŸ”¢ Reply Below Number :_

 1 || Black Pink
 2 || Black Pink 2
 3 || Black Pink 3
 4 || Naruto
 5 || Digital Glitch
 6 || Pixel Glitch
 7 || Comic Style
 8 || Neon Light
 9 || Free Bear
10 || Devil Wings
11 || Futuristic Technology
12 || Silver 3D
13 || 3D Paper Cut
14 || Pubg 1
15 || Pubg 2
16 || Free Fire Cover
17 || Text On Wet Glass
18 || Typography
19 || Modern Gold
20 || Matrix

> á´©Ê€á´á´Šá´‡á´„á´›êœ± á´êœ° á´…Éªá´…á´œÊŸá´€ Ê€á´€êœ±Êœá´Éªá´‹á´€`

        const fdChannel = {
            newsletterJid: "@newsletter",
            newsletterName: "Didula MD V2 ğŸ’š",
            serverMessageId: 999
        };
        const contextMsg = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel
        };
        const msgBody = {
            image: {url:`https://i.ibb.co/tC37Q7B/20241220-122443.jpg`},
            caption: logoMsg,
            contextInfo: contextMsg
        };
        let send = await conn.sendMessage(from, msgBody, {
            'quoted': mek
        })

        conn.ev.on('messages.upsert', async (msgUpdate) => {
            const msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            const selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === send.key.id) {
                switch (selectedOption) {
                    case '1':
                        let data1 = await fetchJson(`${apilink2}/api/logo?url=${logo1}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data1.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '2':
                        let data2 = await fetchJson(`${apilink2}/api/logo?url=${logo2}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data2.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '3':
                        let data3 = await fetchJson(`${apilink2}/api/logo?url=${logo3}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data3.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '4':
                        let data4 = await fetchJson(`${apilink2}/api/logo?url=${logo4}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data4.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '5':
                        let data5 = await fetchJson(`${apilink2}/api/logo?url=${logo5}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data5.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '6':
                        let data6 = await fetchJson(`${apilink2}/api/logo?url=${logo6}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data6.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '7':
                        let data7 = await fetchJson(`${apilink2}/api/logo?url=${logo7}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data7.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '8':
                        let data8 = await fetchJson(`${apilink2}/api/logo?url=${logo8}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data8.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '9':
                        let data9 = await fetchJson(`${apilink2}/api/logo?url=${logo9}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data9.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '10':
                        let data10 = await fetchJson(`${apilink2}/api/logo?url=${logo10}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data10.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '11':
                        let data11 = await fetchJson(`${apilink2}/api/logo?url=${logo11}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data11.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '12':
                        let data12 = await fetchJson(`${apilink2}/api/logo?url=${logo12}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data12.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '13':
                        let data13 = await fetchJson(`${apilink2}/api/logo?url=${logo13}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data13.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '14':
                        let data14 = await fetchJson(`${apilink2}/api/logo?url=${logo14}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data14.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '15':
                        let data15 = await fetchJson(`${apilink2}/api/logo?url=${logo15}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data15.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '16':
                        let data16 = await fetchJson(`${apilink2}/api/logo?url=${logo16}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data16.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '17':
                        let data17 = await fetchJson(`${apilink2}/api/logo?url=${logo17}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data17.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '18':
                        let data18 = await fetchJson(`${apilink2}/api/logo?url=${logo18}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data18.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '19':
                        let data19 = await fetchJson(`${apilink2}/api/logo?url=${logo19}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data19.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '20':
                        let data20 = await fetchJson(`${apilink2}/api/logo?url=${logo20}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data20.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    default:
                        reply("*_Invalid number.Please reply a valid number._*");
                }
            }
        })

    }catch(e){
        console.log(e)
        reply(`${e}`)
    }
});

// Constants for logo URLs
const logo1 = 'https://en.ephoto360.com/create-a-blackpink-style-logo-with-members-signatures-810.html';
const logo2 = `https://en.ephoto360.com/online-blackpink-style-logo-maker-effect-711.html`;
const logo3 = `https://en.ephoto360.com/create-a-blackpink-neon-logo-text-effect-online-710.html`;
const logo4 = `https://en.ephoto360.com/naruto-shippuden-logo-style-text-effect-online-808.html`;
const logo5 = `https://en.ephoto360.com/create-digital-glitch-text-effects-online-767.html`;
const logo6 = `https://en.ephoto360.com/create-pixel-glitch-text-effect-online-769.html`;
const logo7 = `https://en.ephoto360.com/create-online-3d-comic-style-text-effects-817.html`;
const logo8 = `https://en.ephoto360.com/create-colorful-neon-light-text-effects-online-797.html`;
const logo9 = `https://en.ephoto360.com/free-bear-logo-maker-online-673.html`;
const logo10 = `https://en.ephoto360.com/neon-devil-wings-text-effect-online-683.html`;
const logo11 = `https://en.ephoto360.com/light-text-effect-futuristic-technology-style-648.html`;
const logo12 = `https://en.ephoto360.com/create-glossy-silver-3d-text-effect-online-802.html`;
const logo13 = `https://en.ephoto360.com/multicolor-3d-paper-cut-style-text-effect-658.html`;
const logo14 = `https://en.ephoto360.com/free-pubg-logo-maker-online-609.html`;
const logo15 = `https://en.ephoto360.com/pubg-logo-maker-cute-character-online-617.html`;
const logo16 = `https://en.ephoto360.com/create-free-fire-facebook-cover-online-567.html`;
const logo17 = `https://en.ephoto360.com/write-text-on-wet-glass-online-589.html`;
const logo18 = `https://en.ephoto360.com/create-online-typography-art-effects-with-multiple-layers-811.html`;
const logo19 = `https://en.ephoto360.com/modern-gold-5-215.html`;
const logo20 = `https://en.ephoto360.com/matrix-text-effect-154.html`;

const apilink2 = 'https://api-pink-venom.vercel.app';
const caption = `> á´©Ê€á´á´Šá´‡á´„á´›êœ± á´êœ° á´…Éªá´…á´œÊŸá´€ Ê€á´€êœ±Êœá´Éªá´‹á´€`;






//   ================== group category plugin====================



// Helper function to check permissions
const checkPermissions = (isGroup, isAdmins, isOwner, isBotAdmins) => {
    if (!isGroup) return 'This command can only be used in groups.';
    if (!isAdmins && !isOwner) return 'This command can only be used by group admins.';
    if (!isBotAdmins) return 'Bot must be admin to use this command.';
    return null;
};


cmd({
pattern: "del",
react: "âŒ",
alias: ["del"],
desc: "delete message",
category: "group",
use: '.del',
filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants,  isItzcp, groupAdmins, isBotAdmins, isAdmins, reply}) => {
if (!isOwner ||  !isAdmins) return;
try{
if (!m.quoted) return reply(mg.notextfordel);
const key = {
            remoteJid: m.chat,
            fromMe: false,
            id: m.quoted.id,
            participant: m.quoted.sender
        }
        await conn.sendMessage(m.chat, { delete: key })
} catch(e) {
console.log(e);
reply('successful..ğŸ‘¨â€ğŸ’»âœ…')
} 
})






cmd({
    pattern: "join",
    fromMe: true,  // Only bot owner can use this command
    desc: "Make the bot join a group using an invite link.",
    category: "group",
    react: "ğŸŒ€",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, args, q, reply }) => {
    try {
        // Check if invite link is provided
        if (!q || !q.includes("chat.whatsapp.com")) {
            return await reply("Please provide a valid WhatsApp group invite link.");
        }
        // Extract the group code from the invite link
        const inviteCode = q.split("chat.whatsapp.com/")[1];
        // Make the bot join the group using the invite code
        const response = await conn.groupAcceptInvite(inviteCode);
        // Send confirmation message if successfully joined
        if (response) {
            await reply("âœ… Successfully joined the group!");
        } else {
            await reply("âŒ Failed to join the group. Please check the invite link.");
        }
    } catch (e) {
        console.error("Error while joining group:", e);
        await reply("â— An error occurred while trying to join the group.");
    }
});
//============================================================================================================================
// Leave Command
cmd({
    pattern: "left",
    fromMe: true,  // Only bot owner can use this command
    desc: "Make the bot leave the group.",
    category: "group",
    react: "ğŸ‘‹",
    filename: __filename
}, async (conn, mek, m, { from, isGroup, reply }) => {
    try {
        // Check if the command is used in a group
        if (!isGroup) {
            return await reply("âŒ This command can only be used in a group.");
        }
        // Make the bot leave the group
        await conn.groupLeave(from);
        // Send confirmation message after leaving the group
        console.log(`Bot left the group: ${from}`);
    } catch (e) {
        console.error("Error while leaving group:", e);
        await reply("â— An error occurred while trying to leave the group.");
    }
});
//============================================================================================================================
// Hidetag Command
cmd({
    pattern: "hidetag",
    fromMe: true,  // Only bot owner can use this command
    desc: "Send a message with hidden tags to all group members.",
    category: "group",
    react: "ğŸ”",
    filename: __filename
}, async (conn, mek, m, { from, isGroup, args, q, participants, reply }) => {
    try {
        // Check if the command is used in a group
        if (!isGroup) {
            return await reply("âŒ This command can only be used in a group.");
        }
        // Check if a message is provided
        if (!q) {
            return await reply("â— Please provide a message to send.");
        }
        // Extract group participants' contact IDs
        const participantIds = participants.map((participant) => participant.id);
        // Send the message with hidden tags
        await conn.sendMessage(from, { 
            text: q, 
            mentions: participantIds 
        });
        console.log("Hidetag message sent to all group members.");
    } catch (e) {
        console.error("Error while sending hidetag message:", e);
        await reply("â— An error occurred while trying to send the hidetag message.");
    }
});





// Mute Group Command
cmd({
    pattern: "mute",
    react: "ğŸ”‡",
    desc: "close a group",
    category: "group",
    use: '.mute',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{                   
if (!isGroup) return reply(ONLGROUP)
if (!isBotAdmins) return reply(botAdmin)
if (!isAdmins) return reply(ADMIN)

        await conn.groupSettingUpdate(mek.chat, 'announcement')
        const sendmsg = await conn.sendMessage(mek.chat.G_MUTE)
await conn.sendMessage(from, { react: { text: `âœ…`, key: mek.key }}) 
} catch (e) {
reply('ğŸ›‘ GROUP IS CLOSED MY BOT OWNER')
l(e)
}
})

// Unmute Group Command
cmd({
    pattern: "unmute",
    react: "ğŸ”Š",
    desc: "open a group",
    category: "group",
    use: '.unmute',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{                   
if (!isGroup) return reply(ONLGROUP)
if (!isBotAdmins) return reply(botAdmin)
if (!isAdmins) return reply(ADMIN)

        await conn.groupSettingUpdate(mek.chat, 'not_announcement')
        const sendmsg = await conn.sendMessage(mek.chat.G_UNMUTE)
await conn.sendMessage(from, { react: { text: `âœ…`, key: mek.key }}) 
} catch (e) {
reply('ğŸ›‘ GROUP IS OPEN MY BOT OWNER')
l(e)
}
})

// Promote Command
cmd({
    pattern: "promote",
    react: "ğŸ“",
    desc: "promote admin to a member",
    category: "group",
    use: '.promote',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{                   
if (!isGroup) return reply(ONLGROUP)
if (!isBotAdmins) return reply(botAdmin)
if (!isAdmins) return reply(ADMIN)

         let users = mek.mentionedJid ? mek.mentionedJid : mek.quoted ? mek.quoted.sender : q.replace(/[^0-9]/g, '')+'@s.whatsapp.net'
                await conn.groupParticipantsUpdate(mek.chat, [users], 'promote').then((res) => reply(jsonformat(res))).catch((err) => reply(jsonformat(err)))
        reply('ğŸ›‘ GROUP ADMIN PROMOTE BY MY BOT OWNER')
await conn.sendMessage(from, { react: { text: `âœ…`, key: mek.key }}) 
} catch (e) {
reply('*Done âœ“âœ“*')
l(e)
}
})

// Demote Command
cmd({
    pattern: "demote",
    react: "ğŸ“",
    desc: "demote admin to a member",
    category: "group",
    use: '.demote',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{                   
if (!isGroup) return reply(ONLGROUP)
if (!isBotAdmins) return reply(botAdmin)
if (!isAdmins) return reply(ADMIN)

                 let users = mek.mentionedJid ? mek.mentionedJid : mek.quoted ? mek.quoted.sender : q.replace(/[^0-9]/g, '')+'@s.whatsapp.net'
                await conn.groupParticipantsUpdate(mek.chat, [users], 'demote').then((res) => reply(jsonformat(res))).catch((err) => reply(jsonformat(err)))
reply('ğŸ›‘ GROUP ADMIN DEMOTE BY MY BOT OWNER')
await conn.sendMessage(from, { react: { text: `âœ…`, key: mek.key }}) 
} catch (e) {
reply('*Done âœ“âœ“*')
l(e)
}
})

// Remove Member Command
cmd({
    pattern: "remove",
    desc: "Remove a member from the group.",
    category: "group",
    react: "ğŸš«",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isGroup) return reply('This command can only be used in a group.')
        if (!isBotAdmins) return reply('Bot must be an admin to use this command.')
        if (!isAdmins) return reply('You must be an admin to use this command.')

        const user = m.mentioned[0] || m.quoted?.sender
        if (!user) return reply('Please tag or reply to a user to remove.')

        await conn.groupParticipantsUpdate(from, [user], 'remove')
        await reply(`@${user.split('@')[0]} has been removed from the group.`, { mentions: [user] })
    } catch (e) {
        console.log(e)
        reply(`${e}`)
    }
})

// Add Member Command
cmd({
    pattern: "add",
    desc: "Add a member to the group.",
    category: "group",
    react: "âœ…",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isGroup) return reply('This command can only be used in a group.')
        if (!isBotAdmins) return reply('Bot must be an admin to use this command.')
        if (!isAdmins) return reply('You must be an admin to use this command.')

        const user = q.split(' ')[0]
        if (!user) return reply('Please provide a phone number to add.')

        await conn.groupParticipantsUpdate(from, [`${user}@s.whatsapp.net`], 'add')
        await reply(`@${user} has been added to the group.`, { mentions: [`${user}@s.whatsapp.net`] })
    } catch (e) {
        console.log(e)
        reply(`${e}`)
    }
})

// Group Info Command
cmd({
    pattern: "groupinfo",
    desc: "Get information about the group.",
    category: "group",
    filename: __filename,
    react: "â„¹ï¸"
},
async(conn, mek, m, { from, isGroup, groupMetadata, groupName, participants, groupAdmins, reply }) => {
    try {
        if (!isGroup) return reply('This command can only be used in groups.');

        const groupInfo = `*Didula MD V2 ğŸ’š*\n\n
ğŸ“‹ *Group Information*
ğŸ‘¥ *Name:* ${groupName}
ğŸ“ *Description:* ${groupMetadata.desc || 'No description'}
ğŸ†” *ID:* ${from}
ğŸ‘‘ *Owner:* ${groupMetadata.owner || 'Not available'}
ğŸ‘¤ *Members:* ${participants.length}
ğŸ‘® *Admins:* ${groupAdmins.length}
ğŸ“… *Created:* ${new Date(groupMetadata.creation * 1000).toLocaleString()}\n\n*Didula MD V2 ğŸ’š*
        `;
        reply(groupInfo);
    } catch(e) {
        console.error(e);
        reply(`âŒ Error: ${e}`);
    }
})

// Tag Admins Command
cmd({
    pattern: "tagadmin",
    alais:["tagadmins"],
    react: "ğŸ™€",
    desc: "Tags all the admins in the group.",
    category: "group",
    filename: __filename,
},           
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
        if (!isGroup) return reply(`This command is only for groups.`);
        if (!isAdmins) return reply(`This command is only for group admin.`);

        const admins = groupAdmins;
        if (admins.length === 0) {
            return reply('There are no admins in this group.');
        }
        let adminTagMessage = '*TAGGING ALL ADMINS IN THE GROUP ğŸ”³:*\n\n';
        for (let admin of admins) {
            adminTagMessage += `@${admin.split('@')[0]}\n`;
        }
        await conn.sendMessage(from, { text: adminTagMessage, mentions: admins }, { quoted: mek });
    } catch (e) {
        console.error('Error tagging admins:', e);
        reply('you are not an admin.');
    }
})

// Open Time Command
cmd({
    pattern: "opentime",
    react: "ğŸ”–",
    desc: "To open group to a time",
    category: "group",
    use: '.opentime',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{   
if (!isGroup) return reply(ONLGROUP)
if (!isAdmins) return reply(ADMIN)        
  if (args[1] == 'second') {
                    var timer = args[0] * `1000`
                } else if (args[1] == 'minute') {
                    var timer = args[0] * `60000`
                } else if (args[1] == 'hour') {
                    var timer = args[0] * `3600000`
                } else if (args[1] == 'day') {
                    var timer = args[0] * `86400000`
                } else {
                    return reply('*select:*\nsecond\nminute\nhour\n\n*example*\n10 second')
                }
                reply(`Open time ${q} starting from now`)
                setTimeout(() => {
                    var nomor = mek.participant
                    const open = `*OPEN TIME* THE GROUP WAS OPENED BY AWAIS MD TO APPROVED ADMIN\n NOW MEMBERS CAN SEND MESSAGES ğŸ”“`
                    conn.groupSettingUpdate(from, 'not_announcement')
                    reply(open)
                }, timer)
await conn.sendMessage(from, { react: { text: `âœ…`, key: mek.key }}) 
} catch (e) {
reply('*Error !!*')
l(e)
}
})

// Close Time Command
cmd({
    pattern: "closetime",
    react: "ğŸ”–",
    desc: "To close group to a time",
    category: "group",
    use: '.closstime',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{   
if (!isGroup) return reply(ONLGROUP)
if (!isAdmins) return reply(ADMIN)        
                if (args[1] == 'second') {
                    var timer = args[0] * `1000`
                } else if (args[1] == 'minute') {
                    var timer = args[0] * `60000`
                } else if (args[1] == 'hour') {
                    var timer = args[0] * `3600000`
                } else if (args[1] == 'day') {
                    var timer = args[0] * `86400000`
                } else {
                    return reply('*select:*\nsecond\nminute\nhour\n\n*Example*\n10 second')
                }
                reply(`Close time ${q} starting from now`)
                setTimeout(() => {
                    var nomor = m.participant
                    const close = `*CLOSE TIME* GROUP CLOSED BY AWAIS MD AT APPROVED ADMIN\nNOW ONLY ADMIN CAN SEND MESSAGES ğŸ”`
                    conn.groupSettingUpdate(from, 'announcement')
                    reply(close)
                }, timer)
await conn.sendMessage(from, { react: { text: `âœ…`, key: mek.key }}) 
} catch (e) {
reply('*Error !!*')
l(e)
}
})

// Kick All Command
cmd({
    pattern: "kickall",
    desc: "Kicks all non-admin members from the group.",
    react: "ğŸ‘",
    category: "group",
    filename: __filename,
},           
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
      if (!isAdmins) return reply(`Éª É´á´‡á´‡á´… á´€á´…á´ÉªÉ´ ğŸ’€`)
      if (!isOwner) return reply(`Êá´á´œ á´€Ê€á´‡ É´á´á´› á´á´¡É´á´‡Ê€ á´êœ° á´…Éªá´…á´œÊŸá´€ á´á´…`)

        if (!isGroup) return reply(`This command is only for groups.`);
        if (!isBotAdmins) return reply(`I need admin privileges to kick users.`);
        
        const allParticipants = groupMetadata.participants;
        const nonAdminParticipants = allParticipants.filter(member => !groupAdmins.includes(member.id));
        
        if (nonAdminParticipants.length === 0) {
            return reply('There are no non-admin members to kick.');
        }
        
        for (let participant of nonAdminParticipants) {
            await conn.groupParticipantsUpdate(m.chat, [participant.id], "remove");
        }
        
        reply(`Didula MD V2 ğŸ’š Successfully kicked all non-admin members from the group.`);

    } catch (e) {
        console.error('Error kicking users:', e);
        reply('An error occurred while trying to kick all members. Please try again.');
    }
})






//   ================== owner category plugin====================

cmd({
    pattern: "msginfo",
    desc: "Get msg info",
    category: "owner",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{


if(!isOwner) return reply('*_This is an owner cmd._*')

let number = m.quoted.sender.replace('@s.whatsapp.net', '')
    
let inf = `*DIDULA MD V2 MESSEGE INFO*

*â¤ Message ID :* ${m.quoted.id}

*â¤ Message Type :* ${m.quoted.type}

*â¤ Sender Number :* ${number}

> ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ`
const msg = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula MD V2",
            serverMessageId: 999
          };
          const test1 = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: msg
          };
          const test2 = {
            text: inf,
            contextInfo: test1
          };
         await conn.sendMessage(from, test2, {
            'quoted': mek
          })
    
}catch(e){
reply(`${e}`)
}
})





cmd({
    pattern: "block",
    desc: "Block a user.",
    category: "owner",
    react: "ğŸš«",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, quoted, reply }) => {
    if (!isOwner) return reply("âŒ owner command !");
    if (!quoted) return reply("âŒ Please reply to the user you want to block.");

    const user = quoted.sender;
    try {
        await conn.updateBlockStatus(user, 'block');
        reply(`ğŸ˜‘ğŸ–• ${user} blocked successfully.`);
    } catch (error) {
        reply(`âŒ Error blocking user: ${error.message}`);
    }
});

// Unblock User Command
cmd({
    pattern: "unblock",
    desc: "Unblock a user.",
    category: "owner",
    react: "âœ…",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, quoted, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    if (!quoted) return reply("âŒ Please reply to the user you want to unblock.");

    const user = quoted.sender;
    try {
        await conn.updateBlockStatus(user, 'unblock');
        reply(`âœ… User ${user} unblocked successfully.`);
    } catch (error) {
        reply(`âŒ Error unblocking user: ${error.message}`);
    }
});

// Clear All Chats Command
cmd({
    pattern: "clearchats",
    desc: "Clear all chats from the bot.",
    category: "owner",
    react: "ğŸ§¹",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    try {
        const chats = conn.chats.all();
        for (const chat of chats) {
            await conn.modifyChat(chat.jid, 'delete');
        }
        reply("ğŸ§¹ All chats cleared successfully!");
    } catch (error) {
        reply(`âŒ Error clearing chats: ${error.message}`);
    }
});

// Forward Message Command
cmd({
    pattern: "forward",
    desc: "Forward messages",
    alias: ['fo'],
    category: "owner",
    use: ".forward <Jid address>",
    filename: __filename
}, async (conn, mek, store, {
    from,
    quoted,
    q,
    isOwner,
    isMe,
    reply
}) => {
    if (!isOwner & !isMe) {
        return reply("*You Are Not Owner Or Bot*");
    }

    if (!q) {
        return reply("Please provide a target JID address âŒ");
    }

    if (!quoted) {
        return reply("Please reply to a message you want to forward âŒ");
    }

    const forwardMessage = quoted.fakeObj ? quoted.fakeObj : quoted;

    try {
        await conn.sendMessage(q, { forward: forwardMessage }, { quoted: mek });
        return reply(`*Message forwarded successfully to:*\n\n${q} âœ…`);
    } catch (error) {
        console.error("Error forwarding message:", error);
        return reply("Failed to forward the message âŒ");
    }
});

// Restart Bot Command
cmd({
    pattern: "restart",
    desc: "restart the bot",
    category: "owner",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    const {exec} = require("child_process")
    reply("Didula MD V2 ğŸ’š restarting...")
    await sleep(1500)
    exec("pm2 restart all")
}catch(e){
    console.log(e)
    reply(`${e}`)
}
});

/*
// JID Command
cmd({
    pattern: "jid",
    react: "ğŸ’»",
    alias: ["jids"],
    desc: "Check bot's ping",
    category: "owner",
    use: '.ping',
    filename: __filename
},
async(conn, mek, m, {from, mnu, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
    try{
        reply(from)
    } catch (e) {
        reply(`${e}`)
        console.log(e)
    }
});

*/


// Group JIDs List Command
cmd({
    pattern: "gjid",
    desc: "Get the list of JIDs for all groups the bot is part of.",
    category: "owner",
    react: "ğŸ“",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    const groups = await conn.groupFetchAllParticipating();
    const groupJids = Object.keys(groups).join('\n');
    reply(`ğŸ“ *Group JIDs:*\n\n${groupJids}`);
});









//   ================== search category plugin====================
cmd({
    pattern: "npm",
    desc: "Get npm info",
    category: "search",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{


let emptyMsg = `*use  .npm axios*`
if(!q) return reply(emptyMsg)
    
let response = await axios.get(`https://www.npmjs.com/package/${q}`)
let $ = cheerio.load(response.data)

const name = $('#top > div.w-100.ph0-l.ph3.ph4-m > h2 > span').text().trim()
const version = $('#top > div.w-100.ph0-l.ph3.ph4-m > span:nth-child(2)').text().trim()
const date = $('#top > div.w-100.ph0-l.ph3.ph4-m > span:nth-child(4) > time').text().trim()
const ghlink = $('#repository-link').text().trim()
const img = `https://static-production.npmjs.com/58a19602036db1daee0d7863c94673a4.png`
    
let msg = `*DIDULA MD NPM INFO_*

*â¤ Package :* ${name}

*â¤ Version :* ${version}

*â¤ Published :* ${date}

*â¤ Repository :* ${ghlink}

> ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ`

const fdChannel = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula MD V2",
            serverMessageId: 999
          };
          const contextMsg = {
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel
          };
          const msgBody = {
	    image: {url: img},
            caption: msg,
            contextInfo: contextMsg
          };
         await conn.sendMessage(from, msgBody, {
            'quoted': mek
          })

let errrMsg = `*_Cant't find your npm package._*`
	
}catch(e){
console.log(e)
reply(`${errrMsg}`)
}
})




cmd({
    pattern: "cineinfo",
    desc: "cinesubz.co info",
    category: "search",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{



if(!q) return reply("*_Please give me a movie name._*")

let response = await axios.get(`https://cinesubz.co/?s=${q}`);
let $ = cheerio.load(response.data);
let url = $('#contenedor > div.module > div.content.rigth.csearch > div > div:nth-child(2) > article > div.details > div.title > a').attr('href');
    if(!url) {
        let errr = $('#contenedor > div.module > div.content.rigth.csearch > div > div.no-result.animation-2 > h2 > span').text()
        return reply(`No results to show with *${errr}*`)
    }
let result = await axios.get(`${url}`);
$ = cheerio.load(result.data)

const title = $('#single > div.content.right > div.sheader > div.data > h1').text()
const date = $('#single > div.content.right > div.sheader > div.data > div.extra > span.date').text()
const country = $('#single > div.content.right > div.sheader > div.data > div.extra > span.country').text()
const time = $('#single > div.content.right > div.sheader > div.data > div.extra > span.runtime').text()
const rate = $('#repimdb > strong').text()
const director = $('#cast > div:nth-child(2) > div > div.data > div.name > a').text()
const img = $('#single > div.content.right > div.sheader > div.poster > img').attr('src')

let msg = `ğŸŸ *${title}*

ğŸ§¿ *Release Date :* ${date}

ğŸŒ *Country :* ${country}

â± *Duration :* ${time}

â­ *IMDB Rate :* ${rate}

ğŸ¤µâ€â™‚ *Director :* ${director}

ğŸ–‡ *Link :* ${url}

> ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ`

await conn.sendMessage(from, {image:{url: img},caption:msg},{quoted:mek})
    
}catch(e){
console.log(e)
reply(`${e}`)
}
})



cmd({
    pattern: "githubstalk",
    desc: "Fetch detailed GitHub user profile including profile picture.",
    category: "search",
    react: "ğŸ–¥ï¸",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const username = args[0];
        if (!username) {
            return reply("Please provide a GitHub username.");
        }

        const apiUrl = `https://api.github.com/users/${username}`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        let userInfo = `     ğŸ”_*DIDULA-MD-V2 GIT STALK*_ğŸ”
        
ğŸ‘¤ *Username*: ${data.name || data.login}
ğŸ”— *Github Url*:(${data.html_url})
ğŸ“ *Bio*: ${data.bio || 'Not available'}
ğŸ™ï¸ *Location*: ${data.location || 'Unknown'}
ğŸ“Š *Public Repos*: ${data.public_repos}
ğŸ‘¥ *Followers*: ${data.followers} | Following: ${data.following}
ğŸ“… *Created At*: ${new Date(data.created_at).toDateString()}
ğŸ”­ *Public Gists*: ${data.public_gists}

> *á´©Ê€á´á´Šá´‡á´„á´›êœ± á´êœ° á´…Éªá´…á´œÊŸá´€ Ê€á´€êœ±Êœá´Éªá´‹á´€*
`;

         // Sending the image with caption
          const sentMsg = await conn.sendMessage(from, {


          text: userInfo,
          contextInfo: {

          forwardingScore: 999,
          isForwarded: true,
          forwardedNewsletterMessageInfo: {
          newsletterName: 'â—†â”€ã€ˆ âœ¦ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸâœ¦ ã€‰â”€â—†',
          newsletterJid: "",
          },
          externalAdReply: {
              title: `Didula-MD-V2 Github Information`,
              body: `Can't Find The Information. You Can Try Another Way. Error Code 4043`,
              thumbnailUrl: data.avatar_url,
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
              }
                  }
              }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`Ñ”ÑÑÏƒÑ Æ’Ñ”Ñ‚Â¢Ğ½Î¹Î·g âˆ‚Î±Ñ‚Î±: ${e.response ? e.response.data.message : e.message}`);
    }
});





cmd({
    pattern: "ipinfo",
    desc: "Get information about an IP address",
    use: ".ipinfo <IP_address>",
    category: "search",
    filename: __filename
}, async (conn, mek, m, { from, reply, q }) => {
    try {
        if (!q) return reply("â›” Please provide an IP address!");

        const apiUrl = `https://BJ-Devs.serv00.net/Ip-Info.php?ip=${q}`;

        const response = await axios.get(apiUrl);
        const data = response.data;

        // Format the response message
        let resultMessage = `ğŸ” *IP Information:*\n\n`;
        resultMessage += `ğŸŒ IP: ${data.ip}\n`;
        resultMessage += `ğŸŒ Continent: ${data.continent_name} (${data.continent_code})\n`;
        resultMessage += `ğŸ‡¨ğŸ‡³ Country: ${data.country_name} (${data.country_code2})\n`;
        resultMessage += `ğŸ™ï¸ City: ${data.city}\n`;
        resultMessage += `ğŸ“ State/Province: ${data.state_prov}\n`;
        resultMessage += `ğŸ“® Zip Code: ${data.zipcode}\n`;
        resultMessage += `ğŸ“ Latitude: ${data.latitude}\n`;
        resultMessage += `ğŸ“ Longitude: ${data.longitude}\n`;
        resultMessage += `ğŸ“ Calling Code: ${data.calling_code}\n`;
        resultMessage += `ğŸ•’ Time Zone: ${data.time_zone.name}\n`;
        resultMessage += `ğŸ’» ISP: ${data.isp}\n`;
        resultMessage += `ğŸ³ï¸ Country Flag: ${data.country_flag}\n`;

        // Send the response back
        reply(resultMessage);
    } catch (error) {
        console.error(error);
        if (error.response && error.response.data) {
            reply(`Error: ${error.response.data.message}`);
        } else {
            reply('An error occurred while fetching IP information. Please try again later.');
        }
    }
});







cmd({
    pattern: "yts",
    desc: "Search YouTube videos",
    use: ".yts <query>",
    category: "search",
    filename: __filename
}, async (conn, mek, m, { from, q, reply }) => {
    try {
        if (!q) return reply('â›” Please provide a search query!');
        
        const searchResults = await yts(q);
        const videos = searchResults.videos.slice(0, 5); // Get the top 5 results
        
        if (videos.length === 0) {
            return reply('No results found.');
        }
        
        let resultMessage = 'ğŸ¥ *YouTube Search Results:*\n\n';
        videos.forEach((video, index) => {
            resultMessage += `${index + 1}. [${video.title}](${video.url}) - ${video.author.name}\n`;
        });
        
        reply(resultMessage);
    } catch (e) {
        console.error(e);
        reply(`Error: ${e.message}`);
    }
});






// Image Search Command
cmd({
    pattern: "img",
    alias: ["googleimg"],
    react: "ğŸ”",
    desc: "Search for images on Google",
    category: "search",
    use: '.imgsearch <query>',
    filename: __filename
},
async(conn, mek, m, { from, reply, q }) => {
    try {
        if (!q) return await reply("Please provide a search query!");

        g_i_s(q, (error, result) => {
            if (error || !result.length) return reply("No images found!");

            // Send the first 5 images
            const imageUrls = result.slice(0, 5).map(img => img.url);
            imageUrls.forEach(async (url) => {
                await conn.sendMessage(from, { image: { url } }, { quoted: mek });
            });
        });

    } catch (error) {
        console.error(error);
        reply('An error occurred while processing your request. Please try again later.');
    }
});

// Web Search Function (if needed)
cmd({
    pattern: "search",
    alias: ["websearch"],
    react: "ğŸŒ",
    desc: "Search the web for information",
    category: "search",
    use: '.search <query>',
    filename: __filename
},
async(conn, mek, m, { from, reply, q }) => {
    try {
        if (!q) return await reply("Please provide a search query!");

        // Using the search_web function
        const searchResults = await search_web(q);
        await reply(searchResults);

    } catch (error) {
        console.error(error);
        reply('An error occurred while searching. Please try again later.');
    }
});


// Group JIDs Search

// Get Profile Picture Command
cmd({
    pattern: "getpic",
    desc: "Get the group profile picture.",
    category: "search",
    react: "ğŸ–¼ï¸",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isGroup) return reply('This command can only be used in a group.')

        const groupPic = await conn.getProfilePicture(from)
        await conn.sendMessage(from, { 
            image: { url: groupPic }, 
            caption: 'Group Profile Picture' 
        })
    } catch (e) {
        console.log(e)
        reply(`${e}`)
    }
});


cmd({
    pattern: "vv",
    alias: ['retrive', "viewonce"],
    desc: "Fetch and resend a ViewOnce message content (image/video/voice).",
    category: "misc",
    use: '<query>',
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const quotedMessage = m.msg.contextInfo.quotedMessage; // Get quoted message

        if (quotedMessage && quotedMessage.viewOnceMessageV2) {
            const quot = quotedMessage.viewOnceMessageV2;
            if (quot.message.imageMessage) {
                let cap = quot.message.imageMessage.caption;
                let anu = await conn.downloadAndSaveMediaMessage(quot.message.imageMessage);
                return conn.sendMessage(from, { image: { url: anu }, caption: cap }, { quoted: mek });
            }
            if (quot.message.videoMessage) {
                let cap = quot.message.videoMessage.caption;
                let anu = await conn.downloadAndSaveMediaMessage(quot.message.videoMessage);
                return conn.sendMessage(from, { video: { url: anu }, caption: cap }, { quoted: mek });
            }
            if (quot.message.audioMessage) {
                let anu = await conn.downloadAndSaveMediaMessage(quot.message.audioMessage);
                return conn.sendMessage(from, { audio: { url: anu } }, { quoted: mek });
            }
        }

        // If there is no quoted message or it's not a ViewOnce message
        if (!m.quoted) return reply("Please reply to a ViewOnce message.");
        if (m.quoted.mtype === "viewOnceMessage") {
            if (m.quoted.message.imageMessage) {
                let cap = m.quoted.message.imageMessage.caption;
                let anu = await conn.downloadAndSaveMediaMessage(m.quoted.message.imageMessage);
                return conn.sendMessage(from, { image: { url: anu }, caption: cap }, { quoted: mek });
            }
            else if (m.quoted.message.videoMessage) {
                let cap = m.quoted.message.videoMessage.caption;
                let anu = await conn.downloadAndSaveMediaMessage(m.quoted.message.videoMessage);
                return conn.sendMessage(from, { video: { url: anu }, caption: cap }, { quoted: mek });
            }
        } else if (m.quoted.message.audioMessage) {
            let anu = await conn.downloadAndSaveMediaMessage(m.quoted.message.audioMessage);
            return conn.sendMessage(from, { audio: { url: anu } }, { quoted: mek });
        } else {
            return reply("> *This is not a ViewOnce message.*");
        }
    } catch (e) {
        console.log("Error:", e);
        reply("An error occurred while fetching the ViewOnce message.");
    }
});












//   ================== other category plugin====================


const { screenshotV3 } = require('getscreenshot.js')

cmd({
    pattern: "ss",
    desc: "Get screenshots",
    category: "other",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{


if(!q.startsWith('https://')) return reply('*_Please give me a url to get screenshot._*')

let data = await screenshotV3(q)

await conn.sendMessage(from, {image: {url : data }, caption : `> Didula MD V2`}, {quoted : mek})

}catch(e){
console.log(e)
reply(`${e}`)
}
})




cmd({
    pattern: "dog",
    desc: "Fetch a random dog image.",
    category: "other",
    react: "ğŸ¶",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://dog.ceo/api/breeds/image/random`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.message }, caption: '*â—†â”€ã€ˆ âœ¦ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸâœ¦ ã€‰â”€â—†*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`Error fetching dog image: ${e.message}`);
    }
});





cmd({
    pattern: "animeboy",
    desc: "Fetch a random anime boy image.",
    category: "other",
    react: "â¤ï¸",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*â—†â”€ã€ˆ âœ¦ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸâœ¦ ã€‰â”€â—†*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Boy image*: ${e.message}`);
    }
});



cmd({
    pattern: "weather",
    desc: "ğŸŒ¤ Get weather information for a location",
    react: "ğŸŒ¥ï¸",
    category: "other",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        if (!q) return reply("â— Please provide a city name..Usage: .weather [city name]");

        const apiKey = '2d61a72574c11c4f36173b627f8cb177'; 
        const city = q;
        const url = `http://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`;

        const response = await axios.get(url);
        const data = response.data;

        const weather = `
ğŸŒ *Weather Information for ${data.name}, ${data.sys.country}* ğŸŒ

ğŸŒ¡ï¸ *Temperature*: ${data.main.temp}Â°C

ğŸŒ¡ï¸ *Feels Like*: ${data.main.feels_like}Â°C

ğŸŒ¡ï¸ *Min Temp*: ${data.main.temp_min}Â°C

ğŸŒ¡ï¸ *Max Temp*: ${data.main.temp_max}Â°C

ğŸ’§ *Humidity*: ${data.main.humidity}%

â˜ï¸ *Weather*: ${data.weather[0].main}

ğŸŒ«ï¸ *Description*: ${data.weather[0].description}

ğŸ’¨ *Wind Speed*: ${data.wind.speed} m/s

ğŸ“Œ *Pressure*: ${data.main.pressure} hPa

> *â—†â”€ã€ˆ âœ¦ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸâœ¦ ã€‰â”€â—†*
`;

        return reply(weather);
    } catch (e) {
        console.log(e);
        if (e.response && e.response.status === 404) {
            return reply("ğŸš« Â¢Î¹Ñ‚Ñƒ Î·ÏƒÑ‚ Æ’ÏƒÏ…Î·âˆ‚. Ïâ„“Ñ”Î±Ñ•Ñ” Â¢Ğ½Ñ”Â¢Ğº Ñ‚Ğ½Ñ” Ñ•ÏÑ”â„“â„“Î¹Î·g Î±Î·âˆ‚ Ñ‚ÑÑƒ Î±gÎ±Î¹Î·.");
        }
        return reply("âš ï¸ Î±Î· Ñ”ÑÑÏƒÑ ÏƒÂ¢Â¢Ï…ÑÑÑ”âˆ‚ Ï‰Ğ½Î¹â„“Ñ” Ñ‚ÑÎ±Î·Ñ•â„“Î±Ñ‚Î¹Î·g Ñ‚Ğ½Ñ” Ñ‚Ñ”Ï‡Ñ‚. Ïâ„“Ñ”Î±Ñ•Ñ” Ñ‚ÑÑƒ Î±gÎ±Î¹Î· â„“Î±Ñ‚Ñ”Ñ.");
    }
});






// Anime Girl 1 Command
cmd({
    pattern: "animegirl",
    desc: "Fetch a random anime girl image.",
    category: "other",
    react: "ğŸ‘§",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*Didula MD V2 ğŸ’š*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

// Anime Girl 2 Command
cmd({
    pattern: "animegirl2",
    desc: "Fetch a random anime girl image.",
    category: "other",
    react: "ğŸ‘§",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*Didula MD V2 ğŸ’š*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

// Anime Girl 3 Command
cmd({
    pattern: "animegirl3",
    desc: "Fetch a random anime girl image.",
    category: "other",
    react: "ğŸ‘§",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*Didula MD V2 ğŸ’š*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

// Anime Girl 4 Command
cmd({
    pattern: "animegirl4",
    desc: "Fetch a random anime girl image.",
    category: "other",
    react: "ğŸ‘§",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*Didula MD V2 ğŸ’š*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

// Anime Girl 5 Command
cmd({
    pattern: "animegirl5",
    desc: "Fetch a random anime girl image.",
    category: "other",
    react: "ğŸ‘§",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*Didula MD V2 ğŸ’š*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

// Hack Command
cmd({
    pattern: "hack",
    desc: "Displays a dynamic and playful 'Hacking' message for fun.",
    category: "other",
    react: "ğŸ’»",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const steps = [
            'ğŸ’» *HACK STARTING...* ğŸ’»',
            '',
            '*Initializing hacking tools...* ğŸ› ï¸',
            '*Connecting to remote servers...* ğŸŒ',
            '',
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 10%``` â³',
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 20%``` â³',
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 30%``` â³',
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 40%``` â³',
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 50%``` â³',
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 60%``` â³',
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 70%``` â³',
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 80%``` â³',
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 90%``` â³',
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%``` âœ…',
            '',
            'ğŸ”’ *System Breach: Successful!* ğŸ”“',
            'ğŸš€ *Command Execution: Complete!* ğŸ¯',
            '',
            '*ğŸ“¡ Transmitting data...* ğŸ“¤',
            '_ğŸ•µï¸â€â™‚ï¸ Ensuring stealth..._ ğŸ¤«',
            '*ğŸ”§ Finalizing operations...* ğŸ',
            '',
            'âš ï¸ *Note:* All actions are for demonstration purposes only.',
            'âš ï¸ *Reminder:* Ethical hacking is the only way to ensure security.',
            '',
            '> *Didula MD V2 ğŸ’š HACKING-COMPLETE â˜£*'
        ];

        for (const line of steps) {
            await conn.sendMessage(from, { text: line }, { quoted: mek });
            await new Promise(resolve => setTimeout(resolve, 1000)); // Adjust the delay as needed
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error:* ${e.message}`);
    }
});

// Couple PP Command












//   ================== download category plugin====================


const cinesubapi = 'https://rest-api-dark-shan.vercel.app/'

cmd({
    pattern: "cinesearch",
    desc: "Search movies in Cinesubz.co",
    category: "search",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {


        if (!q) return reply("*_Please give me a movie name._*")
        
        const search = await fetchJson(`${cinesubapi}download/cinesubz-search?q=${q}`)
        const array = search.data

        if (array === 'No results found.') {
            return reply("*_Can't find your movie._*")
        }

 const movieDetails = array.map((movie, index) => {
           return `${index + 1}. *Movie Name :* ${movie.title}\n*Type :* ${movie.category}\n*Year :* ${movie.year}\n*Link :* ${movie.link}`
        }).join("\n\n")
        
let searchMsg = `*Didula MD Cinesubz.co SEARCH ğŸ”_*

${movieDetails}

> ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ`
        
        const fdChannel = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula MD V2",
            serverMessageId: 999
          };
          const contextMsg = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel
          };
          const msgBody = {
	    image: { url : `https://files.catbox.moe/za6ytm.jpg` },
            caption: searchMsg,
            contextInfo: contextMsg
          };
         let inf = await conn.sendMessage(from, msgBody, {
            'quoted': mek
          })

//================================================================================================================
	    
conn.ev.on('messages.upsert', async (msgUpdate) => {
            let msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            let selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === inf.key.id) {

		    let index = parseInt(selectedOption);

		    let info = await fetchJson(`${cinesubapi}download/cinesubz-dl?q=${array[index-1].link}`)
		   
		    let arrays =  info.data.download
        
      if (!arrays || arrays.length === 0) {
            return reply("*_No download links available._*")
        }

        const downloadLinks = arrays.map((link, index) => {
            return `${index + 1} || ${link.quality} ( ${link.size} )` 
        }).join("\n")
	    
let msg = `*_Didula MD Cinesubz.co DOWNLOADER ğŸ“¥_*

ğŸŸ *Movie Name :* ${info.data.title}

ğŸ§¿ *Release Date :* ${info.data.date}

ğŸŒ *Country :* ${info.data.country}

â± *Duration :* ${info.data.duration}

â­ *IMDB Rate :* ${info.data.rating}

â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬

ğŸ”¢ Reply Below Number :

${downloadLinks}

> ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ`

const fdChannel = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula MD V2",
            serverMessageId: 999
          };
          const contextMsg = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel,
	        externalAdReply: { 
		                title: 'Didula MD V2',
				body: 'ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ',
				mediaType: 1,
				sourceUrl: `https://chat.whatsapp.com/${code}` ,
                		thumbnailUrl:  info.data.image,
				renderLargerThumbnail: true,
          			showAdAttribution: true
	    		}
          };
          const msgBody = {
            text: msg,
            contextInfo: contextMsg
          };
         let send = await conn.sendMessage(from, msgBody, {
            'quoted': mek
          })

conn.ev.on('messages.upsert', async (msgUpdate) => {
            let msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            let selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === send.key.id) {

		    const indexx = parseInt(selectedOption);

		   if(arrays[indexx - 1].downloadDetails.error === 'Failed to fetch download links.') return reply("*Direct download server error.Please try again after few hours :(*")
		    let downloadUrl = arrays[indexx - 1].downloadDetails.DIRECT_LINK
if(!downloadUrl) {
	return reply("*_Can't download your movie in this quality.Please try another quality._*")
}	    
		    let caption = `${info.data.title} ( ${arrays[indexx - 1].quality} )
      
> ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ`
		    
await conn.sendMessage(from, {document: { url: downloadUrl }, mimetype: "video/mp4", fileName: "ğŸ¬ Didula MD V2 ğŸ¬" + info.data.title + ".mp4", caption: caption}, { quoted: send })

}
})		    
}
})

//===============================================================================================================
	    
}catch(e){
console.log(e)
reply(`${e}`)
}
})

cmd({
    pattern: "cinedl",
    desc: "Download movies in Cinesubz.co",
    category: "download",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {


        if (!q) return reply("*_Please give me a movie name._*")

    const search = await fetchJson(`${cinesubapi}download/cinesubz-search?q=${q}`)
    const searchResult = search.data

        if (searchResult === 'No results found.') {
            return reply("*_Can't find your movie._*")
        }
        
    const info = await fetchJson(`${cinesubapi}download/cinesubz-dl?q=${searchResult[0].link}`)

const array =  info.data.download
        
      if (!array || array.length === 0) {
            return reply("*_No download links available._*")
        }

        const downloadLinks = array.map((link, index) => {
            return `${index + 1} || ${link.quality} ( ${link.size} )` 
        }).join("\n")
	    
let msg = `*_Didula MD V2 Cinesubz.co DOWNLOADER ğŸ“¥_*

ğŸŸ *Movie Name :* ${info.data.title}

ğŸ§¿ *Release Date :* ${info.data.date}

ğŸŒ *Country :* ${info.data.country}

â± *Duration :* ${info.data.duration}

â­ *IMDB Rate :* ${info.data.rating}

â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬

ğŸ”¢ Reply Below Number :

${downloadLinks}

> ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ`

const fdChannel = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula MD V2",
            serverMessageId: 999
          };
          const contextMsg = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel,
	        externalAdReply: { 
		                title: 'Didula MD V2',
				body: 'ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ',
				mediaType: 1,
				sourceUrl: `https://chat.whatsapp.com/${code}` ,
                		thumbnailUrl:  info.data.image,
				renderLargerThumbnail: true,
          			showAdAttribution: true
	    		}
          };
          const msgBody = {
            text: msg,
            contextInfo: contextMsg
          };
         let send = await conn.sendMessage(from, msgBody, {
            'quoted': mek
          })

conn.ev.on('messages.upsert', async (msgUpdate) => {
            const msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            const selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === send.key.id) {

		    const index = parseInt(selectedOption);

		   if(array[index - 1].downloadDetails.error === 'Failed to fetch download links.') return reply("*Direct download server error.Please try again after few hours :(*")
		    let downloadUrl = array[index - 1].downloadDetails.DIRECT_LINK
if(!downloadUrl) {
	return reply("*_Can't download your movie in this quality.Please try another quality._*")
}	    
		    let caption = `${info.data.title} ( ${array[index - 1].quality} )
      
> ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ`
		    
await conn.sendMessage(from, {document: { url: downloadUrl }, mimetype: "video/mp4", fileName: "ğŸ¬ Didula MD V2 ğŸ¬" + info.data.title + ".mp4", caption: caption}, { quoted: send })

    }
})
	    
}catch(e){
console.log(e)
reply(`${e}`)
}
})

cmd({
    pattern: "cinesend",
    desc: "movie send to grp jid",
    category: "owner",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {


        if (!isOwner) {
            return reply("*_This is an owner cmd_*")
	}
        
        if (!q) {
            return reply(
                "*_Please give me a movie name and send jid._*\n\n*Ex :- .cinesend <movie name> & <jid>*"
            )
        }

        const inputParts = q.split(" & ")
        const movieName = inputParts[0]
        const sendJid = inputParts[1]

let MvId; 
if (!sendJid) {
    MvId = id;
} else {
    MvId = sendJid;
}
	    
//========================= Movie Search =================================

const search = await fetchJson(`${cinesubapi}download/cinesubz-search?q=${movieName}`)
        const array = search.data

        if (array === 'No results found.') {
            return reply("*_Can't find your movie._*")
        }

 const movieDetails = array.map((movie, index) => {
           return `${index + 1}. *Movie Name :* ${movie.title}\n*Type :* ${movie.category}\n*Year :* ${movie.year}\n*Link :* ${movie.link}`
        }).join("\n\n")
        
let searchMsg = `*_Didula MD V2 Cinesubz.co SEND ğŸ”_*

â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬

*Send jid :* ${MvId}

â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬

${movieDetails}

> ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ`
	    
//======================================================
	    
let inf = await conn.sendMessage(from, {text: searchMsg}, {quoted: mek})
	    
//======================= Get info by serch reuslt ===================================

conn.ev.on('messages.upsert', async (msgUpdate) => {
            let msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            let selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === inf.key.id) {

		    let index = parseInt(selectedOption);

		    const info = await fetchJson(`${cinesubapi}download/cinesubz-dl?q=${array[index-1].link}`)

            let arrays =  info.data.download
        
      if (!arrays || arrays.length === 0) {
            return reply("*_No download links available._*")
        }

        const downloadLinks = arrays.map((link, index) => {
            return `${index + 1} || ${link.quality} ( ${link.size} )` 
        }).join("\n")

let msg = `*_Didula MD V2 Cinesubz.co SENDER ğŸ“¥_*

â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬

*Send jid :* ${MvId}

â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬

*Movie Name :* ${info.data.title}

*Release Date :* ${info.data.date}

*Country :* ${info.data.country}

*Duration :* ${info.data.duration}

*IMDB Rate :* ${info.data.rating}

ğŸ”¢ Reply Below Number :

0 || Send movie info

${downloadLinks}



>  ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ`
//==========================================================

let send = await conn.sendMessage(from, { image : { url : info.data.image }, caption : msg}, { quoted : inf})
                
//====================== Send info and movie =================

conn.ev.on('messages.upsert', async (msgUpdate) => {
            let msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            let selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === send.key.id) {

		    const indexx = parseInt(selectedOption)
			
                if(indexx > 0) {

		   if(arrays[indexx - 1].downloadDetails.error === 'Failed to fetch download links.') return reply("*Direct download server error.Please try again after few hours :(*")
		    let downloadUrl = arrays[indexx - 1].downloadDetails.DIRECT_LINK
if(!downloadUrl) {
	return reply("*_Can't send your movie in this quality.Please try another quality._*")
}	    

		    let caption = `${info.data.title} ( ${arrays[indexx - 1].quality} )
      
> ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ`

			if(!sendJid) {
await conn.sendMessage(id, {document: { url: downloadUrl }, mimetype: "video/mp4", fileName: info.data.title + ".mp4", caption: caption})
			} else {
await conn.sendMessage(sendJid, {document: { url: downloadUrl }, mimetype: "video/mp4", fileName: info.data.title + ".mp4", caption: caption})
			}
} else {

let sendInfomsg = `ğŸŸ *${info.data.title}*

ğŸ§¿ *Release Date :* ${info.data.date}

ğŸŒ *Country :* ${info.data.country}

â± *Duration :* ${info.data.duration}

â­ *IMDB Rate :* ${info.data.rating}

â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬


> ğŸ”± ğğ«ğ¨ğ£ğğœğ­ğ¬ ğğŸ ğƒğ¢ğğ®ğ¥ğš ğ‘ğšğ¬ğ¡ğ¦ğ¢ğ¤ğš ğŸ’€ğŸ™Œ`

			if(!sendJid) {
await conn.sendMessage(id ,{image:{url: info.data.image},caption: sendInfomsg})	
			} else {
await conn.sendMessage(sendJid ,{image:{url: info.data.image},caption: sendInfomsg})	
			}
}
			
}
})		    
}
})
                
//============================================================
                
}catch(e){
console.log(e)
reply(`${e}`)
}
})



var needus = "ğŸš©*Please Give Me GitHub Repo URL!*" 
var cantf = "ğŸš© *I Can't Find This Repo!*" 
cmd({
    pattern: "gitclone",
    alias: ["gitdl"],
    react: 'ğŸ’«',
    desc: "Download git repos",
    category: "download",
    use: '.gitclone <repo link>',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
      if (!q) return await  reply(needus)
      let regex1 = /(?:https|git)(?::\/\/|@)github\.com[\/:]([^\/:]+)\/(.+)/i
      let linknya = q
      if (!regex1.test(linknya)) return reply("ğŸš©*Please Give Me Valid GitHub Repo Link!*");
      let [, user, repo] = q.match(regex1) || []
      repo = repo.replace(/.git$/, '')
      let url = `https://api.github.com/repos/${user}/${repo}/zipball`
      let filename = (await fetch(url, {
         method: 'HEAD'
      })).headers.get('content-disposition').match(/attachment; filename=(.*)/)[1]
      let wm = `> *á´©Ê€á´á´Šá´‡á´„á´›êœ± á´êœ° á´…Éªá´…á´œÊŸá´€ Ê€á´€êœ±Êœá´Éªá´‹á´€*`
      await conn.sendMessage(from, { document: { url: url }, mimetype: 'application/zip', fileName: filename, caption: wm}, { quoted: mek })
} catch (e) {
reply(cantf)
console.log(e)
}
})






const baseUrl = 'https://vajira-official-api.vercel.app'

cmd({
    pattern: "fb",
    alias: ["facebook"],
    desc: "download fb videos",
    category: "download",
    react: "ğŸ”",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!q && !q.startsWith("https://")) return reply("Please provide a valid Facebook video URL.")
        //fetch data from api  
        let data = await fetchJson(`${baseUrl}/download/fbdown?url=${q}`)
        reply("*Downloading...*")
        //send video (hd,sd)
        await conn.sendMessage(from, { video: { url: data.result.hd }, mimetype: "video/mp4", caption: `*Facebook Video Download*\n\nTitle: ${data.result.title}\nDescription: ${data.result.desc}\n\n á´©Ê€á´á´Šá´‡á´„á´›êœ± á´êœ° á´…Éªá´…á´œÊŸá´€ Ê€á´€êœ±Êœá´Éªá´‹á´€` }, { quoted: mek })
        await conn.sendMessage(from, { video: { url: data.result.sd }, mimetype: "video/mp4", caption: `*Facebook Video Download*\n\nTitle: ${data.result.title}\nDescription: ${data.result.desc}\n\n á´©Ê€á´á´Šá´‡á´„á´›êœ± á´êœ° á´…Éªá´…á´œÊŸá´€ Ê€á´€êœ±Êœá´Éªá´‹á´€` }, { quoted: mek })  
    } catch (e) {
        console.log(e)
        reply(`Sorry, an error occurred while processing your request. Please try again later.`)
    }
})

//tiktok downloader
cmd({
    pattern: "tiktok",
    alias: ["tt"],
    desc: "download tt videos",
    category: "download",
    react: "ğŸ”",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!q && !q.startsWith("https://")) return reply("Please provide a valid TikTok video URL.")
        //fetch data from api  
        let data = await fetchJson(`${baseUrl}/download/tiktokdl?url=${q}`)
        reply("*Downloading...*")
        //send video (wm,nwm)
        await conn.sendMessage(from, { video: { url: data.result.nowm }, mimetype: "video/mp4", caption: `*TikTok Video Download*\n\nTitle: ${data.result.title}\nCaption: ${data.result.caption}\n\n á´©Ê€á´á´Šá´‡á´„á´›êœ± á´êœ° á´…Éªá´…á´œÊŸá´€ Ê€á´€êœ±Êœá´Éªá´‹á´€`, thumbnail: await getBuffer(data.result.thumbnail) }, { quoted: mek })
        await conn.sendMessage(from, { video: { url: data.result.wm }, mimetype: "video/mp4", caption: `*TikTok Video Download*\n\nTitle: ${data.result.title}\nCaption: ${data.result.caption}\n\n á´©Ê€á´á´Šá´‡á´„á´›êœ± á´êœ° á´…Éªá´…á´œÊŸá´€ Ê€á´€êœ±Êœá´Éªá´‹á´€`, thumbnail: await getBuffer(data.result.thumbnail) }, { quoted: mek })  
        //send audio    
        await conn.sendMessage(from, { audio: { url: data.result.mp3 }, mimetype: "audio/mpeg" }, { quoted: mek })  
    } catch (e) {
        console.log(e)
        reply(`Sorry, an error occurred while processing your request. Please try again later.`)
    }
})



cmd({
    pattern: "update",
    desc: "Updates bot system files",
    category: "owner",
    react: "ğŸ”„",
    filename: __filename
},
async(conn, mek, m,{from, reply}) => {
    try {
        await m.react('â¬‡ï¸');
        
        // GitHub raw file URL
        const url = 'https://raw.githubusercontent.com/itsme-didulabot/Didula-MD-DB/main/Didula%20Md%20V2%20-%20System.js';
        
        // Download the file
        const response = await axios.get(url);
        
        if (response.status !== 200) {
            await m.react('âŒ');
            return reply('Failed to download update file');
        }

        // Path to plugins directory
        const pluginPath = path.join(__dirname, '../plugins/system.js');
        
        // Write the file
        fs.writeFileSync(pluginPath, response.data);
        
        await m.react('âœ…');
        reply(`Didula MD V2 updated successfully\n\nplease follow this for more updates https://whatsapp.com/channel/0029VaqqF4GDTkJwKruLSK2f`);

    } catch (error) {
        console.error(error);
        await m.react('âŒ');
        reply('Error during update: ' + error.message);
    }
});



cmd({
    pattern: "insta",
    desc: "To download instagram videos.",
    category: "download",
    react: "ğŸ“©",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

  if (!args[0]) {
    return reply('*`Please give me a valid instagram link.`*');
  }

  await m.react('ğŸ“¥');
  let res;
  try {
    res = await igdl(args[0]);
  } catch (error) {
    return reply('*`Error Obtaning Data.`*');
  }

  let result = res.data;
  if (!result || result.length === 0) {
    return reply('*`No results found.`*');
  }

  let data;
  try {
    data = result.find(i => i.resolution === "720p (HD)") || result.find(i => i.resolution === "360p (SD)");
  } catch (error) {
    return reply('*`error data loss.`*');
  }

  if (!data) {
    return reply('*`Î·Ïƒ âˆ‚Î±Ñ‚Î± Æ’ÏƒÏ…Î·âˆ‚.`*');
  }

  await m.react('âš¡');
  let video = data.url;
  let dev = '*â—†â”€ã€ˆ âœ¦ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸâœ¦ ã€‰â”€â—†*'

  try {
    await conn.sendMessage(m.chat, { video: { url: video }, caption: dev, fileName: 'ig.mp4', mimetype: 'video/mp4' }, { quoted: m });
  } catch (error) {
    return reply('*`Error Download Video`*');
  await m.react('âŒ');
  }
}catch(e){
console.log(e)
  reply(`${e}`)
}
});




cmd({
    pattern: "dl",
    react: "ğŸ“¥",
    alias: ["dlurl"],
    desc: "Direct link uploader",
    category: "download",
    use: '.dl <link>',
    filename: __filename
},
async (conn, mek, m, { 
    from, quoted, body, args, q, reply 
}) => {
    try {
        if (!q) return reply('â— Please provide a link!');
        
        // Validate URL format
        const isValidUrl = (url) => {
            try {
                new URL(url);
                return true;
            } catch {
                return false;
            }
        };

        if (!isValidUrl(q)) return reply('âŒ Invalid URL format! Please check the link.');

        // Fetch the file data from the provided link
        const axios = require('axios');
        const mimeTypes = require('mime-types');
        
        const res = await axios.get(q, { 
            responseType: 'arraybuffer',
            timeout: 15000 // Set a timeout of 15 seconds
        });

        // Get MIME type and extension
        const mime = res.headers['content-type'] || 'application/octet-stream';
        const extension = mimeTypes.extension(mime) || 'unknown';

        // Get file size from headers
        const fileSize = res.headers['content-length'] || 0;
        const maxFileSize = 2048 * 2048 * 2048; // 10 MB

        if (fileSize > maxFileSize) {
            return reply('â— File is too large to upload (limit: 10MB).');
        }

        // Define file name
        const fileName = `Didula MD V2 ğŸ’š.${extension}`;

        // Send the file as a document
        await conn.sendMessage(
            from,
            {
                document: { url: q },
                caption: "> Didula MD V2 ğŸ’š",
                mimetype: mime,
                fileName: fileName
            },
            { quoted: mek }
        );

    } catch (error) {
        // Handle errors gracefully
        console.error(error);
        reply(`âŒ Error: ${error.message}`);
    }
});











// Download APK
cmd({
    pattern: "apk",
    desc: "Downloads Apk",
    use: ".apk <app_name>",
    react: "ğŸ“¥",
    category: "download",
    filename: __filename
}, async (conn, mek, m, { from, q, reply }) => {
    const appId = q.trim();
    if (!appId) return reply(`Please provide an app name`);

    reply("_Downloading " + appId + "_");

    try {
        const appInfo = await scraper.aptoideDl(appId);
        const buff = await getBuffer(appInfo.link);

        if (!buff || !appInfo.appname) {
            return await conn.sendMessage(from, { react: { text: 'âŒ', key: mek.key } });
        }

        await conn.sendMessage(
            from,
            { document: buff, caption: `*Didula MD V2 ğŸ’š*`, mimetype: "application/vnd.android.package-archive", filename: `${appInfo.appname}.apk` },
            { quoted: mek }
        );

        await conn.sendMessage(from, { react: { text: 'âœ…', key: mek.key } });
        reply("*_Download Success_*");
    } catch (e) {
        console.error(e);
        await conn.sendMessage(from, { react: { text: 'âŒ', key: mek.key } });
        reply(`Error: ${e.message}`);
    }
});





// Download Wallpaper
cmd({
    pattern: "wallpaper",
    alias: ["wallpaperdownload"],
    react: "ğŸ–¼ï¸",
    desc: "Download a random wallpaper",
    category: "download",
    use: '.wallpaper',
    filename: __filename
}, async (conn, mek, m, { from, reply }) => {
    try {
        const searchUrl = 'https://unsplash.com/s/photos/wallpaper';
        const { data } = await axios.get(searchUrl);
        const $ = cheerio.load(data);

        const results = [];
        $('figure img').each((index, element) => {
            const imgUrl = $(element).attr('src');
            results.push(imgUrl);
        });

        if (results.length === 0) {
            return await reply("No wallpapers found!");
        }

        // Randomly select an image from the results
        const selectedImage = results[Math.floor(Math.random() * results.length)];

        // Send the selected image directly
        await conn.sendMessage(from, { image: { url: selectedImage }, caption: "Here is your wallpaper!" }, { quoted: mek });

    } catch (error) {
        console.error(error);
        reply('An error occurred while downloading the wallpaper. Please try again later.');
    }
});















//   ================== main category plugin====================




cmd({
    pattern: "anime",
    desc: "anime the bot",
    category: "main",
    react: "â›±ï¸",
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

let dec = `*â—†â”€ã€ˆ âœ¦ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸâœ¦ ã€‰â”€â—†*`
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/b26f27aa5daaada031b90.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/51b44e4b086667361061b.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/7d165d73f914985542537.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/3d9732d2657d2d72dc102.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/8daf7e432a646f3ebe7eb.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/7514b18ea89da924e7496.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/ce9cb5acd2cec7693d76b.jpg`},caption:dec},{quoted:mek});

}catch(e){
console.log(e)
reply(`${e}`)
}
})










cmd({
    pattern: "broadcast",
    fromMe: true,
    desc: "ğŸ“¢ Broadcast a message to all chats",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { args, reply }) => {
    const message = args.join(" ");
    if (!message) return reply("â— Please provide a message to broadcast.");

    const chats = await conn.getAllChats();
    let successCount = 0;

    for (let chat of chats) {
        try {
            await conn.sendMessage(chat.id, { text: `ğŸ“¢ *DIDULA MD V2 ğŸ’š BROADCAST MESSAGE*\n\n${message}` });
            successCount++;
        } catch (error) {
            console.error(`Failed to send broadcast to ${chat.id}:`, error);
        }
    }

    reply(`âœ… Broadcast sent to ${successCount} chats successfully!`);
});

//======================================================================================================================
cmd({
    pattern: "ban",
    fromMe: true,
    desc: "ğŸš« Ban a user from using the bot",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { args, reply, isOwner }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    if (!args[0]) return reply("â— Please provide a user's number to ban.");

    const userToBan = args[0].replace(/[^0-9]/g, "") + "@s.whatsapp.net";
    config.banned.push(userToBan);

    reply(`ğŸš« User ${args[0]} has been banned from using the bot.`);
});

//======================================================================================================================
cmd({
    pattern: "unban",
    desc: "âœ… Unban a user",
    fromMe: true,
    category: "main",
    filename: __filename
}, async (conn, mek, m, { args, reply, isOwner }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    if (!args[0]) return reply("â— Please provide a user's number to unban.");

    const userToUnban = args[0].replace(/[^0-9]/g, "") + "@s.whatsapp.net";
    config.banned = config.banned.filter(user => user !== userToUnban);

    reply(`âœ… User ${args[0]} has been unbanned.`);
});

//======================================================================================================================
cmd({
    pattern: "setbotname",
    desc: "âœï¸ Change the bot's name",
    fromMe: true,
    category: "main",
    filename: __filename
}, async (conn, mek, m, { args, reply, isOwner }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");

    const newName = args.join(" ");
    if (!newName) return reply("â— Please provide a new name for the bot.");

    await conn.updateProfileName(newName);
    reply(`âœ… Bot's name has been changed to: *${newName}*`);
});

//======================================================================================================================
cmd({
    pattern: "setbotbio",
    desc: "âœï¸ Change the bot's bio",
    fromMe: true,
    category: "main",
    filename: __filename
}, async (conn, mek, m, { args, reply, isOwner }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");

    const newBio = args.join(" ");
    if (!newBio) return reply("â— Please provide a new bio for the bot.");

    await conn.updateProfileStatus(newBio);
    reply(`âœ… Bot's bio has been changed to: *${newBio}*`);
});

//======================================================================================================================


//======================================================================================================================
cmd({
    pattern: "setpp",
    desc: "ğŸ–¼ï¸ Set bot's profile picture",
    fromMe: true,
    category: "main",
    filename: __filename
}, async (conn, mek, m, { reply, isOwner }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");

    const media = m.message?.imageMessage || m.message?.videoMessage;
    if (!media || !media.url) return reply("â— No image or video found.");

    try {
        const buffer = await conn.downloadMediaMessage(m);
        await conn.updateProfilePicture(buffer);
        reply("âœ… Profile picture has been updated.");
    } catch (error) {
        console.error("Failed to update profile picture:", error);
        reply("â— Failed to update profile picture.");
    }
});

let autoBioInterval;

//======================================================================================================================
cmd({
    pattern: "setautobio",
    alias: ["autobio"],
    fromMe: true,
    desc: "Enable or disable the AutoBIO feature.",
    category: "main",
    react: "ğŸ› ï¸",
    filename: __filename
}, async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");

    config.autoBioEnabled = !config.autoBioEnabled;

    if (config.autoBioEnabled) {
        reply("ğŸ› ï¸ AutoBIO feature has been *enabled*! ğŸ”„");
        startAutoBio(conn);
    } else {
        reply("ğŸ› ï¸ AutoBIO feature has been *disabled*! ğŸš«");
        stopAutoBio();
    }
});

// 2. Start AutoBIO
function startAutoBio(conn) {
    // Clear any existing interval to avoid duplicates
    if (autoBioInterval) clearInterval(autoBioInterval);

    // Set a new interval to update the bio every minute (or any preferred time)
    autoBioInterval = setInterval(async () => {
        const time = new Date().toLocaleTimeString();  // Get the current time
        const bioText = `Didula MD V2 ğŸ’š`;  // Set the bio text with time
        await conn.updateProfileStatus(bioText);  // Update the bot's bio
    }, 60 * 1000);  // 1 minute interval
}

// 3. Stop AutoBIO
function stopAutoBio() {
    if (autoBioInterval) {
        clearInterval(autoBioInterval);  // Stop the interval
        autoBioInterval = null;
        console.log("ğŸ› ï¸ AutoBIO feature stopped.");  // Log the stopping of the feature
    }
}












const badWords = [
    "ê¦¾", "~@0~*", "ê¦½", "á¬´", ".@@", "@@@", "\u0000", "á€¼", "à«€", 
    "ğ‘‡‚ğ‘†µğ‘†´ğ‘†¿", "ğ‘œ¦à£¯", "İ‰âƒªâƒŸÌ¸Ì·"
];

// Bad word filter plugin
cmd({
    on: "body"
}, async (conn, mek, m, { from, body, isGroup, isAdmins, isBotAdmins, reply, sender }) => {
    try {
        const lowerCaseMessage = body.toLowerCase();
        const containsBadWord = badWords.some(word => lowerCaseMessage.includes(word));

        if (containsBadWord) {
            // Delete the message
            await conn.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: mek.key.id, participant: sender } });

            // Notify the user
            await conn.sendMessage(from, { text: "âš ï¸ Your message contained inappropriate content and has been removed. âš ï¸" }, { quoted: mek });

            // Block the sender
            await conn.updateBlockStatus(sender, 'block');

            // Remove the sender from the group if in a group
            if (isGroup && isBotAdmins) {
                await conn.groupParticipantsUpdate(from, [sender], 'remove');
            }
        }
    } catch (error) {
        console.error("Error processing message:", error);
        reply("An error occurred while processing your message. Please try again later.");
    }
});


// Ping Command
cmd({
    pattern: "ping",
    react: "ğŸ¤–",
    alias: ["speed"],
    desc: "Check bot\'s ping",
    category: "main",
    use: '.ping',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
var inital = new Date().getTime();
let ping = await conn.sendMessage(from , { text: '*â—†â”€ã€ˆ âœ¦ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸâœ¦ ã€‰â”€â—†*'  }, { quoted: mek } )
var final = new Date().getTime();
await conn.sendMessage(from, { delete: ping.key })
return await conn.sendMessage(from , { text: '*ğŸ”¥Pong*\n *' + (final - inital) + ' ms* '  }, { quoted: mek } )
} catch (e) {
reply('*Error !!*')
l(e)
}
})




// Alive Command
cmd({
    pattern: "alive",
    desc: "Check if the bot is alive.",
    category: "main",
    react: "âœ…",
    filename: __filename
}, async (conn, mek, m, { from, quoted, reply }) => {
    try {


        // Send a message indicating the bot is alive
        const message = await conn.sendMessage(from, { text: '*â—†â”€ã€ˆ âœ¦ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸâœ¦ ã€‰â”€â—†*' });

        // Simulate some processing time
        const startTime = Date.now();
        await new Promise(resolve => setTimeout(resolve, 500)); // Simulating a delay
        const endTime = Date.now();
        const ping = endTime - startTime;

        // Send the alive response with additional information
        await conn.sendMessage(from, {
            document: { url: pdfUrl }, // Path to your PDF file
            fileName: 'ã€ˆ âœ¦ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸâœ¦ ã€‰', // Filename for the document
            mimetype: "application/pdf",
            fileLength: 99999999999999,
            image: { url: 'https://i.ibb.co/tC37Q7B/20241220-122443.jpg' },
            pageCount: 2024,
            caption: `ğ——ğ—¶ğ—±ğ˜‚ğ—¹ğ—® ğ— ğ—— ğ—©ğŸ® ğ—œğ˜€ ğ—”ğ—¹ğ—¶ğ˜ƒğ—²! \n\nâ° ğ—¥ğ—²ğ˜€ğ—½ğ—¼ğ—»ğ˜€ğ—² ğ—§ğ—¶ğ—ºğ—² : ${ping} ms\n\nğ—§ğ˜†ğ—½ğ—²   .ğ—ºğ—²ğ—»ğ˜‚ ğ—¼ğ—¿ .ğ—¹ğ—¶ğ˜€ğ˜ ğ—³ğ—¼ğ—¿ ğ—´ğ—²ğ˜ ğ—°ğ—¼ğ—ºğ—ºğ—®ğ—»ğ—±ğ˜€\n\nã€ˆ âœ¦ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸâœ¦ ã€‰`,
            contextInfo: {
                forwardingScore: 999,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterName: 'ã€ˆ âœ¦ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸâœ¦ ã€‰',
                    newsletterJid: "120363343196447945@newsletter",
                },
                externalAdReply: {
                    title: 'Â©ã€ˆ âœ¦ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸâœ¦ ã€‰',
                    body: ' *ã€ˆ âœ¦ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸâœ¦ ã€‰*',
                    thumbnailUrl: 'https://i.ibb.co/tC37Q7B/20241220-122443.jpg',
                    sourceUrl: 'https://wa.me/message/DIDULLTK7ZOGH1',
                    mediaType: 1,
                    renderLargerThumbnail: true
                }
            }
        });

    } catch (e) {
        console.error(e);
        reply(`${e}`);
    }
});






// System Info Command
cmd({
    pattern: "sysinfo",
    alias: ["system"],
    react: "ğŸ–¥ï¸",
    desc: "Get system information",
    category: "main",
    use: '.sysinfo',
    filename: __filename
},
async(conn, mek, m, { from, reply }) => {
    try {
        const data = await si.getAllData();
        const msg = `
            *Didula MD V2 ğŸ’š System Information:*
            â€¢ CPU: ${data.cpu.manufacturer} ${data.cpu.brand}
            â€¢ Cores: ${data.cpu.cores}
            â€¢ RAM: ${(data.mem.total / 1e9).toFixed(2)} GB
            â€¢ OS: ${data.os.distro} ${data.os.release}
        `;
        await reply(msg);
    } catch (error) {
        console.error(error);
        reply('An error occurred while fetching system information. Please try again later.');
    }
});


// Unified Menu Command
cmd({
    pattern: "downloadmenu",
    react: "ğŸ“¥",
    desc: "get cmd list",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (commands[i].category === 'download' && !commands[i].dontAddCommandList) {
                menu += `â•­â”â”â”ã€˜ ğŸ“¥ ğ”»ğ•†ğ•â„•ğ•ƒğ•†ğ”¸ğ”»ğ•Š ğŸ“¥ ã€™\nâ”ƒ â€ â„‚ğ•†ğ•„ğ•„ğ”¸â„•ğ”»: ${commands[i].pattern}\nâ”ƒ â€ ğ”»ğ”¼ğ•Šâ„‚: ${commands[i].desc}\nâ”ƒ â€ ğ•Œğ•Šğ”¸ğ”¾ğ”¼: ${commands[i].use}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¦\n\n`;
            }
        }
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: menu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});

cmd({
    pattern: "mainmenu",
    react: "ğŸ¯",
    desc: "get cmd list",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (commands[i].category === 'main' && !commands[i].dontAddCommandList) {
                menu += `â•­â”â”â”ã€˜ ğŸ® ğ•„ğ”¸ğ•€â„• ğ•„ğ”¼â„•ğ•Œ ğŸ® ã€™\nâ”ƒ â€ â„‚ğ•†ğ•„ğ•„ğ”¸â„•ğ”»: ${commands[i].pattern}\nâ”ƒ â€ ğ”»ğ”¼ğ•Šâ„‚: ${commands[i].desc}\nâ”ƒ â€ ğ•Œğ•Šğ”¸ğ”¾ğ”¼: ${commands[i].use}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¦\n\n`;
            }
        }
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: menu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});

cmd({
    pattern: "groupmenu",
    react: "ğŸ‘¥",
    desc: "get cmd list",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (commands[i].category === 'group' && !commands[i].dontAddCommandList) {
                menu += `â•­â”â”â”ã€˜ ğŸ‘¥ ğ”¾â„ğ•†ğ•Œâ„™ğ•Š ğŸ‘¥ ã€™\nâ”ƒ â€ â„‚ğ•†ğ•„ğ•„ğ”¸â„•ğ”»: ${commands[i].pattern}\nâ”ƒ â€ ğ”»ğ”¼ğ•Šâ„‚: ${commands[i].desc}\nâ”ƒ â€ ğ•Œğ•Šğ”¸ğ”¾ğ”¼: ${commands[i].use}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¦\n\n`;
            }
        }
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: menu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});

cmd({
    pattern: "ownermenu",
    react: "ğŸ‘‘",
    desc: "get cmd list",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (commands[i].category === 'owner' && !commands[i].dontAddCommandList) {
                menu += `â•­â”â”â”ã€˜ ğŸ‘‘ ğ•†ğ•â„•ğ”¼â„ ğŸ‘‘ ã€™\nâ”ƒ â€ â„‚ğ•†ğ•„ğ•„ğ”¸â„•ğ”»: ${commands[i].pattern}\nâ”ƒ â€ ğ”»ğ”¼ğ•Šâ„‚: ${commands[i].desc}\nâ”ƒ â€ ğ•Œğ•Šğ”¸ğ”¾ğ”¼: ${commands[i].use}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¦\n\n`;
            }
        }
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: menu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});

cmd({
    pattern: "convertmenu",
    react: "ğŸ”„",
    desc: "get cmd list",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (commands[i].category === 'convert' && !commands[i].dontAddCommandList) {
                menu += `â•­â”â”â”ã€˜ ğŸ”„ â„‚ğ•†â„•ğ•ğ”¼â„ğ•‹ ğŸ”„ ã€™\nâ”ƒ â€ â„‚ğ•†ğ•„ğ•„ğ”¸â„•ğ”»: ${commands[i].pattern}\nâ”ƒ â€ ğ”»ğ”¼ğ•Šâ„‚: ${commands[i].desc}\nâ”ƒ â€ ğ•Œğ•Šğ”¸ğ”¾ğ”¼: ${commands[i].use}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¦\n\n`;
            }
        }
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: menu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});

cmd({
    pattern: "searchmenu",
    react: "ğŸ”",
    desc: "get cmd list",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (commands[i].category === 'search' && !commands[i].dontAddCommandList) {
                menu += `â•­â”â”â”ã€˜ ğŸ” ğ•Šğ”¼ğ”¸â„â„‚â„ ğŸ” ã€™\nâ”ƒ â€ â„‚ğ•†ğ•„ğ•„ğ”¸â„•ğ”»: ${commands[i].pattern}\nâ”ƒ â€ ğ”»ğ”¼ğ•Šâ„‚: ${commands[i].desc}\nâ”ƒ â€ ğ•Œğ•Šğ”¸ğ”¾ğ”¼: ${commands[i].use}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¦\n\n`;
            }
        }
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: menu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});

cmd({
    pattern: "menu",
    desc: "Check commands.",
    category: "main",
    react: "ğŸ“œ",
    filename: __filename
}, async (conn, mek, m, { from, quoted, reply }) => {
    try {
        const menuMessage = `â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€
â”‚ ğŸŒŸ ğ•ğ”¼ğ•ƒâ„‚ğ•†ğ•„ğ”¼ ğ•‹ğ•† ğ”»ğ•€ğ”»ğ•Œğ•ƒğ”¸ ğ•„ğ”» ğŸŒŸ
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€
â•”â•â•â•â•â•â•â•â•â•â•âœ§
â•‘ ğŸ‘‘ ğ•†ğ•â„•ğ”¼â„: ğ”»ğ•€ğ”»ğ•Œğ•ƒğ”¸ â„ğ”¸ğ•Šâ„ğ•„ğ•€ğ•‚ğ”¸
â•‘ ğŸ“ â„•ğ•Œğ•„ğ”¹ğ”¼â„: +94741820962
â•‘ âš¡ ğ•Šâ„™ğ”¼ğ”¼ğ”»: 000.23
â•‘ ğŸ’¾ ğ•„ğ”¼ğ•„ğ•†â„ğ•: 64GB
â•šâ•â•â•â•â•â•â•â•â•â•âœ§

    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â€
    â”‚ ğ•„ğ”¼â„•ğ•Œ ğ•ƒğ•€ğ•Šğ•‹
    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â€

â”ƒ ğŸ“œ .ğš–ğšŠğš’ğš—ğš–ğšğš—ğš
â”ƒ ğŸ” .ğšœğšğšŠğš›ğšŒğš‘ğš–ğšğš—ğš
â”ƒ ğŸ‘¥ .ğšğš›ğš˜ğšğš™ğš–ğšğš—ğš
â”ƒ ğŸ‘‘ .ğš˜ğš ğš—ğšğš›ğš–ğšğš—ğš
â”ƒ ğŸ“¥ .ğšğš˜ğš ğš—ğš•ğš˜ğšŠğšğš–ğšğš—ğš
â”ƒ ğŸ”„ .ğšŒğš˜ğš—ğšŸğšğš›ğšğš–ğšğš—ğš
â”ƒ ğŸ¯ .ğš˜ğšğš‘ğšğš›ğš–ğšğš—ğš

â•­â”â”â”ã€˜ â„¹ï¸ ğ”¹ğ•†ğ•‹ ğ•€â„•ğ”½ğ•† ã€™
â”ƒ ğŸ‘‘ ğ•†ğ•â„•ğ”¼â„: ğ”»ğ•€ğ”»ğ•Œğ•ƒğ”¸ â„ğ”¸ğ•Šâ„ğ•„ğ•€ğ•‚ğ”¸
â”ƒ ğŸ› ï¸ ğ”»ğ”¼ğ•: â„‚ğ•ğ”¹ğ”¼â„ ğ•ğ”¸â„•ğ•€ğ•ğ”¸
â”ƒ ğŸ“ â„‚ğ•†â„•ğ•‹ğ”¸â„‚ğ•‹: +94741820962
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¦`;

        await conn.sendMessage(from, {
            document: { url: pdfUrl },
            fileName: 'ğŸŒŸ ğ”»ğ•€ğ”»ğ•Œğ•ƒğ”¸ ğ•„ğ”» ğŸŒŸ',
            mimetype: "application/pdf",
            fileLength: 99999999999999,
            pageCount: 2024,
            caption: menuMessage,
            contextInfo: {
                forwardingScore: 999,
                isForwarded: true,
                externalAdReply: {
                    title: 'ğŸŒŸ ğ”»ğ•€ğ”»ğ•Œğ•ƒğ”¸ ğ•„ğ”» ğ”¹ğ•†ğ•‹ ğŸŒŸ',
                    body: 'âœ¨ ğ•ğ• ğ•¦ğ•£ ğ•Œğ•ğ•¥ğ•šğ•ğ•’ğ•¥ğ•– ğ•ğ•™ğ•’ğ•¥ğ•¤ğ”¸ğ•¡ğ•¡ ğ”¸ğ•¤ğ•¤ğ•šğ•¤ğ•¥ğ•’ğ•Ÿğ•¥ âœ¨',
                    thumbnailUrl: 'https://i.ibb.co/tC37Q7B/20241220-122443.jpg',
                    sourceUrl: 'https://wa.me/94741820962',
                    mediaType: 1,
                    renderLargerThumbnail: true
                }
            }
        });
    } catch (e) {
        console.error(e);
        reply(`${e}`);
    }
});

cmd({
    pattern: "allmenu",
    alias: ["list"],
    react: "ğŸ“œ",
    desc: "Get all commands list.",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (!commands[i].dontAddCommandList) {
                menu += `â•­â”â”â”ã€˜ ğŸŒŸ ğ”»ğ•€ğ”»ğ•Œğ•ƒğ”¸ ğ•„ğ”» ğŸŒŸ ã€™\nâ”ƒ â€ â„‚ğ•†ğ•„ğ•„ğ”¸â„•ğ”»: ${commands[i].pattern}\nâ”ƒ â€ ğ”»ğ”¼ğ•Šâ„‚: ${commands[i].desc}\nâ”ƒ â€ ğ•Œğ•Šğ”¸ğ”¾ğ”¼: ${commands[i].use}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¦\n\n`;
            }
        }

        let madeMenu = menu || 'No commands available at the moment.';
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: madeMenu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});










//   ================== main category plugin====================





//   ======================== song Video =========================

cmd({
    pattern: "video",
    alias: ["ytmp4", "play"],
    react: "ğŸ¥",
    desc: "Download Youtube video",
    category: "download",
    use: '.video < Yt url or Name >',
    filename: __filename
}, async (conn, mek, m, { from, prefix, quoted, q, reply }) => {
    try {
        if (!q) return await reply("âš ï¸ Please provide a YouTube URL or video name!");

        const yt = await ytsearch(q);
        if (yt.results.length < 1) return reply("âŒ No results found!");

        let yts = yt.results[0];
        let apiUrl = `https://dark-shan-yt.koyeb.app/download/ytmp4?url=${encodeURIComponent(yts.url)}&quality=3`;
        
        // Fetch the download token
        let response = await fetch(apiUrl);
        let data = await response.json();
        let downloadUrl = data.download;

        let ytmsg = `â•­â”â”â”ã€” *ğŸŒŸ DIDULA MD V2 ğŸŒŸ* ã€•â”â”â”â”ˆâŠ·
â”ƒâ–¸â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ–¸â”ƒ ğŸ“½ï¸ *VIDEO DOWNLOADER*
â”ƒâ–¸â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·Â·Â·
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•­â”â”ââ”âª¼
â”‡ğŸ“Œ *Title:* ${yts.title}
â”‡â±ï¸ *Duration:* ${yts.timestamp}
â”‡ğŸ‘€ *Views:* ${yts.views}
â”‡ğŸ‘¤ *Author:* ${yts.author.name}
â”‡ğŸ”— *Link:* ${yts.url}
â•°â”â”â‘â”âª¼

*ğŸ’« Quality Video Downloader By Didula MD V2*`;

        await conn.sendMessage(from, { image: { url: yts.thumbnail }, caption: ytmsg }, { quoted: mek });
        await conn.sendMessage(from, { video: { url: downloadUrl }, mimetype: "video/mp4" }, { quoted: mek });
        await conn.sendMessage(from, {
            document: { url: downloadUrl },
            mimetype: "video/mp4",
            fileName: `${yts.title}.mp4`,
            caption: `ğŸ¥ *${yts.title}*\n\n*ğŸŒŸ Created By:* Didula Rashmika\n*ğŸ¤– Bot:* Didula MD V2`
        }, { quoted: mek });

    } catch (e) {
        console.log(e);
        reply("âŒ An error occurred. Please try again later.");
    }
});





cmd({
    pattern: "song",
    alias: ["ytdl3", "yta"],
    react: "ğŸµ",
    desc: "Download Youtube song",
    category: "download",
    use: '.song < Yt url or Name >',
    filename: __filename
}, async (conn, mek, m, { from, prefix, quoted, q, reply }) => {
    try {
        if (!q) return await reply("âš ï¸ Please provide a YouTube URL or song name!");

        const yt = await ytsearch(q);
        if (yt.results.length < 1) return reply("âŒ No results found!");

        let yts = yt.results[0];
        let apiUrl = `https://manul-ofc-ytdl-paid-30a8f429a0a6.herokuapp.com/download/audio?url=${encodeURIComponent(yts.url)}`;
        
        let response = await fetch(apiUrl);
        let data = await response.json();
        
        if (!data.status || !data.downloadUrl) {
            return reply("âŒ Failed to fetch download URL");
        }

        let downloadUrl = data.downloadUrl;

        let ytmsg = `â•­â”â”â”ã€” *ğŸŒŸ DIDULA MD V2 ğŸŒŸ* ã€•â”â”â”â”ˆâŠ·
â”ƒâ–¸â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ–¸â”ƒ ğŸµ *MUSIC DOWNLOADER*
â”ƒâ–¸â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·Â·Â·
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•­â”â”ââ”âª¼
â”‡ğŸ§ *Title:* ${yts.title}
â”‡â±ï¸ *Duration:* ${yts.timestamp}
â”‡ğŸ‘€ *Views:* ${yts.views}
â”‡ğŸ‘¤ *Author:* ${yts.author.name}
â”‡ğŸ”— *Link:* ${yts.url}
â•°â”â”â‘â”âª¼

*ğŸ’« High Quality Audio By Didula MD V2*`;

        await conn.sendMessage(from, { image: { url: yts.thumbnail }, caption: ytmsg }, { quoted: mek });
        await conn.sendMessage(from, { audio: { url: downloadUrl }, mimetype: "audio/mpeg" }, { quoted: mek });
        await conn.sendMessage(from, {
            document: { url: downloadUrl },
            mimetype: "audio/mpeg",
            fileName: `${yts.title}.mp3`,
            caption: `ğŸµ *${yts.title}*\n\n*ğŸŒŸ Created By:* Didula Rashmika\n*ğŸ¤– Bot:* Didula MD V2`
        }, { quoted: mek });

    } catch (e) {
        console.log(e);
        reply("âŒ An error occurred. Please try again later.");
    }
});

cmd({ 
    pattern: "songc", 
    alias: ["ytdl3", "yta"], 
    react: "ğŸµ", 
    desc: "Download Youtube song as voice note",
    category: "download", 
    use: '.songc < Yt url or Name >', 
    filename: __filename 
}, async (conn, mek, m, { from, prefix, quoted, q, reply }) => { 
    try { 
        if (!q) return await reply("âš ï¸ Please provide a YouTube URL or song name!");

        const yt = await ytsearch(q);
        if (yt.results.length < 1) return reply("âŒ No results found!");

        let yts = yt.results[0];
        let apiUrl = `https://manul-ofc-ytdl-paid-30a8f429a0a6.herokuapp.com/download/audio?url=${encodeURIComponent(yts.url)}`;
        
        let response = await fetch(apiUrl);
        let data = await response.json();
        
        if (!data.status || !data.downloadUrl) {
            return reply("âŒ Failed to fetch download URL");
        }

        let downloadUrl = data.downloadUrl;

        let ytmsg = `â•­â”â”â”ã€” *ğŸŒŸ DIDULA MD V2 ğŸŒŸ* ã€•â”â”â”â”ˆâŠ·
â”ƒâ–¸â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ–¸â”ƒ ğŸµ *MUSIC DOWNLOADER*
â”ƒâ–¸â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·Â·Â·
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•­â”â”ââ”âª¼
â”‡ğŸ§ *Title:* ${yts.title}
â”‡â±ï¸ *Duration:* ${yts.timestamp}
â”‡ğŸ‘€ *Views:* ${yts.views}
â”‡ğŸ‘¤ *Author:* ${yts.author.name}
â”‡ğŸ”— *Link:* ${yts.url}
â•°â”â”â‘â”âª¼

*ğŸ’« High Quality Audio By Didula MD V2*`;

        await conn.sendMessage(from, { image: { url: yts.thumbnail }, caption: ytmsg }, { quoted: mek });
        await conn.sendMessage(from, { audio: { url: downloadUrl }, mimetype: "audio/mpeg", ptt: true }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply("âŒ An error occurred. Please try again later.");
    }
});



// ===================== song and video ========================== //









cmd({
    pattern: "heartreact",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.heartreact on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.HEART_REACT == 'true') return reply('already on ')
  await input_set('HEART_REACT' , 'true')
  return reply('heartreact turned on')
  }
if ( q == 'off' ) {
   if ( config.HEART_REACT !== 'true') return reply('already off')
  await input_set('HEART_REACT' , 'false')
  return reply('heartreact turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "autovoice",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.autovoice on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.AUTO_VOICE == 'true') return reply('already on ')
  await input_set('AUTO_VOICE' , 'true')
  return reply('autovoice turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_VOICE !== 'true') return reply('already off')
  await input_set('AUTO_VOICE' , 'false')
  return reply('autovoice turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "autosticker",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.autosticmer on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.AUTO_STICKER == 'true') return reply('already on ')
  await input_set('AUTO_STICKER' , 'true')
  return reply('autosticker turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_STICKER !== 'true') return reply('already off')
  await input_set('AUTO_STICKER' , 'false')
  return reply('autosticker turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "autobio",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.autobio on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.AUTO_BIO == 'true') return reply('already on ')
  await input_set('AUTO_BIO' , 'true')
  return reply('autobio turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_BIO !== 'true') return reply('already off')
  await input_set('AUTO_BIO' , 'false')
  return reply('autobio turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "autowelcome",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.autowelcome on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.AUTO_WELCOME == 'true') return reply('already on ')
  await input_set('AUTO_WELCOME' , 'true')
  return reply('autowelcome turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_WELCOME !== 'true') return reply('already off')
  await input_set('AUTO_WELCOME' , 'false')
  return reply('autowelcome turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "antibot",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.antibot on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.ANTI_BOT == 'true') return reply('already on ')
  await input_set('ANTI_BOT' , 'true')
  return reply('antibot turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_BOT !== 'true') return reply('already off')
  await input_set('ANTI_BOT' , 'false')
  return reply('antibot turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "antilink",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.antilink on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.ANTI_LINK == 'true') return reply('already on ')
  await input_set('ANTI_LINK' , 'true')
  return reply('antilink turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_LINK !== 'true') return reply('already off')
  await input_set('ANTI_LINK' , 'false')
  return reply('antilink turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "antibad",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.antibad on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");
if (q == 'on') {
  if ( config.ANTI_BAD == 'true') return reply('already on ')
  await input_set('ANTI_BAD' , 'true')
  return reply('antibad turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_BAD !== 'true') return reply('already off')
  await input_set('ANTI_BAD' , 'false')
  return reply('antibad turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})        


cmd({
    pattern: "autostatus",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.autostatus on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.AUTO_READ_STATUS == 'true') return reply('already on ')
  await input_set('AUTO_READ_STATUS' , 'true')
  return reply('autostatus turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_READ_STATUS !== 'true') return reply('already off')
  await input_set('AUTO_READ_STATUS' , 'false')
  return reply('autostatus turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "autotyping",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.autotyping on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.AUTO_TYPING == 'true') return reply('already on ')
  await input_set('AUTO_TYPING' , 'true')
  return reply('autotyping turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_TYPING !== 'true') return reply('already off')
  await input_set('AUTO_TYPING' , 'false')
  return reply('autotyping turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})        

cmd({
    pattern: "autorecording",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.autorecording on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.RECORDING == 'true') return reply('already on ')
  await input_set('RECORDING' , 'true')
  return reply('autorecording turned on')
  }
if ( q == 'off' ) {
   if ( config.RECORDING !== 'true') return reply('already off')
  await input_set('RECORDING' , 'false')
  return reply('autorecording turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})        

cmd({
    pattern: "cmdread",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.autotyping on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.READ_CMD == 'true') return reply('already on ')
  await input_set('READ_CMD' , 'true')
  return reply('cmd turned on')
  }
if ( q == 'off' ) {
   if ( config.READ_CMD !== 'true') return reply('already off')
  await input_set('READ_CMD' , 'false')
  return reply('cmdread turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})        

cmd({
    pattern: "autoreact",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.autoreact on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");
if (q == 'on') {
  if ( config.AUTO_REACT == 'true') return reply('already on ')
  await input_set('AUTO_REACT' , 'true')
  return reply('autoreact turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_REACT !== 'true') return reply('already off')
  await input_set('AUTO_REACT' , 'false')
  return reply('autoreact turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})        



cmd({
    pattern: "alwaysonline",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.alwaysonline on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.ALWAYS_ONLINE == 'true') return reply('already on ')
  await input_set('ALWAYS_ONLINE' , 'true')
  return reply('alwaysonline turned on')
  }
if ( q == 'off' ) {
   if ( config.ALWAYS_ONLINE !== 'true') return reply('already off')
  await input_set('ALWAYS_ONLINE' , 'false')
  return reply('alwaysonline turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})        

cmd({
    pattern: "212block",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.212block on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.NUMBER_212_BLOCK == 'true') return reply('already on ')
  await input_set('NUMBER_212_BLOCK' , 'true')
  return reply('212block turned on')
  }
if ( q == 'off' ) {
   if ( config.NUMBER_212_BLOCK !== 'true') return reply('already off')
  await input_set('NUMBER_212_BLOCK' , 'false')
  return reply('212block turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "anticall",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.anticall on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.ANTI_CALL == 'true') return reply('already on ')
  await input_set('ANTI_CALL' , 'true')
  return reply('anticall turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_CALL !== 'true') return reply('already off')
  await input_set('ANTI_CALL' , 'false')
  return reply('anticall turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "antidelete",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.antidelete on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.ANTI_DELETE == 'true') return reply('already on ')
  await input_set('ANTI_DELETE' , 'true')
  return reply('antidelete turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_DELETE !== 'true') return reply('already off')
  await input_set('ANTI_DELETE' , 'false')
  return reply('antidelete turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "aichat",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.aichat on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");        
if (q == 'on') {
  if ( config.AI_CHAT == 'true') return reply('already on ')
  await input_set('AI_CHAT' , 'true')
  return reply('aichat turned on')
  }
if ( q == 'off' ) {
   if ( config.AI_CHAT !== 'true') return reply('already off')
  await input_set('AI_CHAT' , 'false')
  return reply('aichat turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "autosongsend",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.autosongsend on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
    if (!isOwner) return reply("âŒ You are not the owner!");        
    if (q == 'on') {
        if (config.AUTO_SONG_SENDER == 'true') return reply('already on');
        await input_set('AUTO_SONG_SENDER', 'true');
        return reply('autosongsend turned on');
    }
    if (q == 'off') {
        if (config.AUTO_SONG_SENDER !== 'true') return reply('already off');
        await input_set('AUTO_SONG_SENDER', 'false');
        return reply('autosongsend turned off');
    }
} catch (e) {
    reply('*Error !!*');
    l(e);
}
});


cmd({
    pattern: "mode",
    react: "ğŸ—£ï¸",
    desc: "",
    category: "",
    use: '.mode public/private',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("âŒ You are not the owner!");                
if (q == 'private') {
  if ( config.MODE == 'private') return reply('already private ')
  await input_set('MODE' , 'private')
  return reply('private mode turned on')
  }
if ( q == 'public' ) {
   if ( config.MODE !== 'public') return reply('already public')
  await input_set('MODE' , 'public')
  return reply('public mode turned off')
}
if ( q == 'inbox' ) {
   if ( config.MODE !== 'inbox') return reply('already inbox')
  await input_set('MODE' , 'inbox')
  return reply('inbox mode turned off')
}
if ( q == 'groups' ) {
   if ( config.MODE !== 'groups') return reply('already groups')
  await input_set('MODE' , 'groups')
  return reply('groups mode turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "settings",
    react: "ğŸ—£ï¸",
    alias: ["setting"],
    desc: "Check bot online or not.",
    category: "main",
    filename: __filename
}, 
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isOwner) return;

        const vv = await conn.sendMessage(from, {
            image: { url: 'https://files.catbox.moe/za6ytm.jpg' },
            caption: `*[ â€¢  DIDULA-MD-V2 - SETTINGSâ€ â€¢ ]*
*â•­â”ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢*
*â”Š* *â™¾ï¸ AUTO_READ_STATUS:* â  ${config.AUTO_READ_STATUS}
*â”Š* *â™¾ï¸ MODE:* â  ${config.MODE} 
*â”Š* *â™¾ï¸ AI_CHAT:* â  ${config.AI_CHAT} 
*â”Š* *â™¾ï¸ ANTI_DELETE:* â  ${config.ANTI_DELETE} 
*â”Š* *â™¾ï¸ AUTO_VOICE:* â  ${config.AUTO_VOICE} 
*â”Š* *â™¾ï¸ AUTO_STICKER:* â  ${config.AUTO_STICKER} 
*â”Š* *â™¾ï¸ ALIVE_IMG:* â  ${config.ALIVE_IMG}
*â”Š* *â™¾ï¸ ALIVE_MSG:* â  ${config.ALIVE_MSG}  
*â”Š* *â™¾ï¸ SUDO:* â  ${config.SUDO}
*â”Š* *â™¾ï¸ ANTI_LINK:* â  ${config.ANTI_LINK}
*â”Š* *â™¾ï¸ ANTI_CALL:* â  ${config.ANTI_CALL} 
*â”Š* *â™¾ï¸ ANTI_BAD:* â  ${config.ANTI_BAD} 
*â”Š* *â™¾ï¸ PREFIX:* â  [${config.PREFIX}]
*â”Š* *â™¾ï¸ AUTO_RECORDING:* â  ${config.RECORDING} 
*â”Š* *â™¾ï¸ HEART_REACT:* â  ${config.HEART_REACT} 
*â”Š* *â™¾ï¸ FOOTER:* â  ${config.FOOTER}
*â”Š* *â™¾ï¸ AUTO_SONG_SENDER:* â  ${config.AUTO_SONG_SENDER} 
*â”Š* *â™¾ï¸ CMD_READ:* â  ${config.READ_CMD}
*â•°â”ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ      ğŸ”—  *CUSTOMIZE YOUR SETTINGS* â¤µï¸
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ       ğŸ”§ *OPTIONS MENU* ğŸ”§
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ƒ

â”£â” *_WORK MODE_* â¤µï¸
â”ƒ   â”£ 1.1 ğŸ”¹ *Public Work*
â”ƒ   â”£ 1.2 ğŸ”¹ *Private Work*
â”ƒ   â”£ 1.3 ğŸ”¹ *Groups Only*
â”ƒ   â”— 1.4 ğŸ”¹ *Inbox Only*

â”£â” *_AUTO VOICE_* â¤µï¸
â”ƒ   â”£ 2.1 ğŸ”Š *Auto Voice On*
â”ƒ   â”— 2.2 ğŸ”• *Auto Voice Off*

â”£â” *_AUTO STATUS SEEN_* â¤µï¸
â”ƒ   â”£ 3.1 ğŸ‘ï¸â€ğŸ—¨ï¸ *Auto Read Status On*
â”ƒ   â”— 3.2 ğŸ‘ï¸âŒ *Auto Read Status Off*

â”£â” *_AUTO BIO_* â¤µï¸
â”ƒ   â”£ 4.1 âœï¸ *Auto Bio On*
â”ƒ   â”— 4.2 âœï¸âŒ *Auto Bio Off*

â”£â” *_AUTO TYPING_* â¤µï¸
â”ƒ   â”£ 5.1 ğŸ“ *Activate Auto Typing*
â”ƒ   â”— 5.2 ğŸ“âŒ *Deactivate Auto Typing*

â”£â” *_AUTO COMMAND READ_* â¤µï¸
â”ƒ   â”£ 6.1 ğŸ–Šï¸ *Activate Auto Command Read*
â”ƒ   â”— 6.2 ğŸ–Šï¸âŒ *Deactivate Auto Command Read*

â”£â” *_ANTI CALL_* â¤µï¸
â”ƒ   â”£ 7.1 ğŸ”Š *Anti Call On*
â”ƒ   â”— 7.2 ğŸ”• *Anti Call Off*

â”£â” *_HEART REACT_* â¤µï¸
â”ƒ   â”£ 8.1 âœï¸ *Heart React On*
â”ƒ   â”— 8.2 âœï¸âŒ *Heart React Off*

â”£â” *_ANTI DELETE_* â¤µï¸
â”ƒ   â”£ 9.1 ğŸ“ *Activate Anti Delete*
â”ƒ   â”— 9.2 ğŸ“âŒ *Deactivate Anti Delete*

â”£â” *_AUTO STICKER_* â¤µï¸
â”ƒ   â”£ 10.1 ğŸ‘ï¸â€ğŸ—¨ï¸ *Auto Sticker On*
â”ƒ   â”— 10.2 ğŸ‘ï¸âŒ *Auto Sticker Off*

â”£â” *_AI CHAT* â¤µï¸
â”ƒ   â”£ 11.1 ğŸ“ *Activate Ai Chat*
â”ƒ   â”— 11.2 ğŸ“âŒ *Deactivate Ai Chat*

â”£â” *_ANTI LINK_* â¤µï¸
â”ƒ   â”£ 12.1 ğŸ–Šï¸ *Activate Anti Link*
â”ƒ   â”— 12.2 ğŸ–Šï¸âŒ *Deactivate Anti Link*

â”£â” *_ANTI BAD_* â¤µï¸
â”ƒ   â”£ 13.1 ğŸ‘ï¸â€ğŸ—¨ï¸ *Anti Bad On*
â”ƒ   â”— 13.2 ğŸ‘ï¸âŒ *Anti Bad Off*

â”£â” *_AUTO RECORDING_* â¤µï¸
â”ƒ   â”£ 14.1 ğŸ”Š *Auto Recording On*
â”ƒ   â”— 14.2 ğŸ”• *Auto Recording Off*

â”£â” *_AUTO SONG SENDER_* â¤µï¸
â”ƒ   â”£ 15.1 ğŸ‘ï¸â€ğŸ—¨ï¸ *Auto Song Sender On*
â”ƒ   â”— 15.2 ğŸ‘ï¸âŒ *Auto Song Sender Off*
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

> *Â©á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê DIDULA*
`
        }, { quoted: mek });

        conn.ev.on('messages.upsert', async (msgUpdate) => {
            const msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            const selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === vv.key.id) {
                switch (selectedOption) {
                    case '1.1':
                        reply(".mode public" );
                        reply(".restart");
                        break;
                    case '1.2':               
                        reply(".mode private");
                        reply(".restart");
                        break;
                    case '1.3':               
                          reply(".mode groups");
                        reply(".restart");
                      break;
                    case '1.4':     
                        reply(".mode inbox");
                        reply(".restart");
                      break;
                    case '2.1':     
                        reply("autovoice on");
                        reply(".restart");
                        break;
                    case '2.2':     
                        reply(".autovoice off");
                        reply(".restart");
                    break;
                    case '3.1':    
                        reply(".autostatus on");
                        reply(".restart");
                    break;
                    case '3.2':    
                        reply(".autostatus off");
                        reply(".restart");
                    break;
                    case '4.1': 
                    reply(".autobio on");
                    reply(".restart");
                    break;
                    case '4.2': 
                    reply(".autobio off");
                    reply(".restart");
                    break;
                    case '5.1':      
                        reply(".autotyping on");
                        reply(".restart");
                        break;
                    case '5.2':   
                        reply(".autotyping off");
                        reply(".restart");
                    break;
                    case '6.1': 
                        reply(".cmdread on");
                        reply(".restart");
                    break;
                    case '6.2':   
                        reply(".cmdread off");
                        reply(".restart");
                    break;
                    case '7.1': 
                        reply(".anticall on");
                        reply(".restart");
                    break;
                    case '7.2':   
                        reply(".anticall off");
                        reply(".restart");
                        break;
                    case '8.1': 
                        reply(".heartreact on");
                        reply(".restart");
                    break;
                    case '8.2':   
                        reply(".heartreact off");
                        reply(".restart");
                        break;
                    case '9.1': 
                        reply(".antidelete on");
                        reply(".restart");
                    break;
                    case '9.2':   
                        reply(".antidelete off");
                        reply(".restart");
                        break;
                    case '10.1': 
                        reply(".autosticker on");
                        reply(".restart");
                    break;
                    case '10.2':   
                        reply(".autosticker off");
                        reply(".restart");
                        break;
                    case '11.1': 
                        reply(".aichat on");
                        reply(".restart");
                    break;
                    case '11.2':   
                        reply(".aichat off");
                        reply(".restart");
                        break;
                    case '12.1': 
                        reply(".antilink on");
                        reply(".restart");
                    break;
                    case '12.2':   
                        reply(".antilink off");
                        reply(".restart");
                        break;
                    case '13.1': 
                        reply(".antibad on");
                        reply(".restart");
                    break;
                    case '13.2':   
                        reply(".antibad off");
                        reply(".restart");
                        break;
                    case '14.1': 
                        reply(".autorecording on");
                        reply(".restart");
                    break;
                    case '14.2':   
                        reply(".autorecording off");
                        reply(".restart");
                        break;
                    case '15.1': 
                        reply(".autosongsend on");
                        reply(".restart");
                    break;
                    case '15.2':   
                        reply(".autosongsend off");
                        reply(".restart");

                        break;
                    default:
                        reply("Invalid option. Please select a valid optionğŸ”´");
                }

            }
        });

    } catch (e) {
        console.error(e);
        await conn.sendMessage(from, { react: { text: 'âŒ', key: mek.key } })
        reply('An error occurred while processing your request.');
    }
});













cmd({
    pattern: "upgrade",
    desc: "Performs complete system upgrade (update â†’ reload â†’ restart)",
    category: "owner",
    filename: __filename,
    react: "âš¡"
},
async(conn, mek, m, {from, isOwner, reply}) => {
    try {
        if (!isOwner) return reply("Only bot owners can use this command.");

        // Step 1: Update System Files 
        await m.react('â¬‡ï¸');
        reply("ğŸ”„ Starting system upgrade...\n\n1ï¸âƒ£ Updating system files...");

        const url = 'https://raw.githubusercontent.com/itsme-didulabot/Didula-MD-DB/main/Didula%20Md%20V2%20-%20System.js';
        const response = await axios.get(url);

        if (response.status !== 200) {
            await m.react('âŒ');
            return reply('Failed to download update file');
        }

        const pluginPath = path.join(__dirname, '../plugins/system.js');
        fs.writeFileSync(pluginPath, response.data);

        await sleep(1000);
        reply("âœ… System files updated successfully\n\n2ï¸âƒ£ Reloading commands...");

        // Step 2: Reload Commands
        const pluginsDir = path.join(__dirname, '../plugins');
        const files = fs.readdirSync(pluginsDir);

        for (const file of files) {
            if (file.endsWith('.js')) {
                const filePath = path.join(pluginsDir, file);
                delete require.cache[require.resolve(filePath)];
                require(filePath);
                console.log(`Reloaded ${file}`);
            }
        }

        await sleep(1000);
        reply("âœ… Commands reloaded successfully\n\n3ï¸âƒ£ Restarting bot...");

        // Step 3: Restart Bot
        await sleep(1000);
        reply("Didula MD V2 ğŸ’š restarting...\n\nPlease wait 1-2 minutes for the bot to come back online.\n\nFollow for updates: https://whatsapp.com/channel/0029VaqqF4GDTkJwKruLSK2f");

        await m.react('âœ…');
        await sleep(1500);

        // Execute restart using pm2
        require('child_process').exec("pm2 restart all");

    } catch (error) {
        console.error(error);
        await m.react('âŒ');
        reply('Upgrade failed: ' + error.message);
    }
});


// à·„à·”à¶­à·Šà¶­à· à·„à·”à¶­à·Šà¶­à· à·„à·”à¶­à·Šà¶­à· ğŸŒà¶•à¶š à¶¸à·”à¶½à·’à¶±à·Šà¶¸ à¶­à·’à¶ºà¶´à¶±à·Š ğŸŒğŸ˜‚

//  ğŸ˜‚à¶¸à·šà¶š à¶­à¶¸à¶ºà·’ à·„à·”à¶­à·Šà¶­à· main plugin à¶‘à¶š 



cmd({
    pattern: "couple",
    desc: "Get random couple photo",
    category: "other",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{


let data = await fetchJson(`https://api.fgmods.xyz/api/img/couple?apikey=nRHt2lt5`)

let boy = `*_Boy_*

> á´©Ê€á´á´Šá´‡á´„á´›êœ± á´êœ° á´…Éªá´…á´œÊŸá´€ Ê€á´€êœ±Êœá´Éªá´‹á´€`

const fdChannel = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula-MD V2",
            serverMessageId: 999
          };
          const contextMsg = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel
          };
          const msgBody = {
            image: {url: `${data.result.boy}`},
            caption: boy,
            contextInfo: contextMsg
          };
         await conn.sendMessage(from, msgBody, {
            'quoted': mek
          })

let girl = `*_Girl_*

> á´©Ê€á´á´Šá´‡á´„á´›êœ± á´êœ° á´…Éªá´…á´œÊŸá´€ Ê€á´€êœ±Êœá´Éªá´‹á´€`

const fdChannel2 = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula-MD V2",
            serverMessageId: 999
          };
          const contextMsg2 = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel2
          };
          const msgBody2 = {
            image: {url: `${data.result.girl}`},
            caption: girl,
            contextInfo: contextMsg2
          };
         await conn.sendMessage(from, msgBody2, {
            'quoted': mek
          })

}catch(e){
console.log(e)
reply(`${e}`)
}
})










// ship command 
const toM = (a) => '@' + a.split('@')[0];
cmd({
    pattern: "ship",
    alias: ["cup", "love"],
    desc: "Randomly pairs the command user with another group member.",
    react: "â¤ï¸",
    category: "other",
    filename: __filename,
}, 
async (conn, mek, m, { from, isGroup, groupMetadata, reply }) => {
    try {
        // Ensure command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Get group participants
        const participants = groupMetadata.participants.map(p => p.id);

        if (participants.length < 2) {
            return reply("Not enough members to pair.");
        }

        // Sender of the command
        const sender = m.sender;

        // Randomly select another participant
        let randomParticipant;
        do {
            randomParticipant = participants[Math.floor(Math.random() * participants.length)];
        } while (randomParticipant === sender);

        // Pairing message
        const message = `${toM(sender)} â¤ï¸ ${toM(randomParticipant)}\nCongratulations ğŸ’–ğŸ»`;

        // Send the message with contextInfo
        await conn.sendMessage(from, {
            text: message,
            contextInfo: {
                mentionedJid: [sender, randomParticipant], // Mention both users
                forwardingScore: 999,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: '120363343196447945@newsletterr',
                    newsletterName: 'Didula MD',
                    serverMessageId: 143,
                },
            },
        });
    } catch (e) {
        console.error("Error in ship command:", e);
        reply("An error occurred while processing the command. Please try again.");
    }
});
// Insult


// joke 

cmd({
    pattern: "joke",
    desc: "ğŸ˜‚ Get a random joke",
    react: "ğŸ¤£",
    category: "other",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        const url = 'https://official-joke-api.appspot.com/random_joke';  // API for random jokes
        const response = await axios.get(url);
        const joke = response.data;

        const jokeMessage = `
ğŸ˜‚ *Here's a random joke for you!* ğŸ˜‚

*${joke.setup}*

${joke.punchline} ğŸ˜„

> *Â©Didula MD*`;

        return reply(jokeMessage);
    } catch (e) {
        console.log(e);
        return reply("âš ï¸ En Error Appears.");
    }
});

// fact

cmd({
    pattern: "fact",
    desc: "ğŸ§  Get a random fun fact",
    react: "ğŸ§ ",
    category: "other",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        const url = 'https://uselessfacts.jsph.pl/random.json?language=en';  // API for random facts
        const response = await axios.get(url);
        const fact = response.data.text;

        const funFact = `
ğŸ§  *Random Fun Fact* ğŸ§ 

${fact}

Isn't that interesting? ğŸ˜„
`;

        return reply(funFact);
    } catch (e) {
        console.log(e);
        return reply("âš ï¸ An error occurred while fetching a fun fact. Please try again later.");
    }
});


// fancy 

cmd({
  pattern: "fancy",
  alias: ['font', "style"],
  react: 'âœï¸',
  desc: "Convert text into various fonts.",
  category: "tools",
  filename: __filename
}, async (conn, mek, m, { from, quoted, body, args, q, reply }) => {
  try {
    if (!q) {
      return reply("Please provide text to convert into fonts.");
    }

    let response = await axios.get('https://www.dark-yasiya-api.site/other/font?text=' + encodeURIComponent(q));
    let data = response.data;

    if (!data.status) {
      return reply("Error fetching fonts. Please try again later.");
    }

    let fontResults = data.result.map(font => '*' + font.name + ":*\n" + font.result).join("\n\n");

    // Message formatting
    let message = `*Didula-MD FANCY FONTS*:\n\n${fontResults}\n\n> *BY Didula-MD*`;

    // Sending the message with context info
    await conn.sendMessage(
      from,
      {
        text: message,
        contextInfo: {
          mentionedJid: [m.sender],
          forwardingScore: 999,
          isForwarded: true,
          forwardedNewsletterMessageInfo: {
            newsletterJid: '120363343196447945@newsletterr',
            newsletterName: 'Didula-MD',
            serverMessageId: 143
          }
        }
      },
      { quoted: mek }
    );

  } catch (error) {
    console.error(error);
    reply("An error occurred while fetching fonts.");
  }
});

// pick-up line

cmd({
    pattern: "pickupline",
    alias: ["pickup"],
    desc: "Get a random pickup line from the API.",
    react: "ğŸ’¬",
    category: "other",
    filename: __filename,
}, 
async (conn, mek, m, { from, reply }) => {
    try {
        // Fetch pickup line from the API
        const res = await fetch('https://api.popcat.xyz/pickuplines');

        if (!res.ok) {
            throw new Error(`API request failed with status ${res.status}`);
        }

        const json = await res.json();

        // Log the API response (for debugging purposes)
        console.log('JSON response:', json);

        // Format the pickup line message
        const pickupLine = `*Here's a pickup line for you:*\n\n"${json.pickupline}"\n\n> *Â© Powered By Didula MD*`;

        // Send the pickup line to the chat
        await conn.sendMessage(from, { text: pickupLine }, { quoted: m });

    } catch (error) {
        console.error("Error in pickupline command:", error);
        reply("Sorry, something went wrong while fetching the pickup line. Please try again later.");
    }
});

// char

cmd({
    pattern: "character",
    alias: ["char"],
    desc: "Check the character of a mentioned user.",
    react: "ğŸ”¥",
    category: "other",
    filename: __filename,
}, 
async (conn, mek, m, { from, isGroup, text, reply }) => {
    try {
        // Ensure the command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Extract the mentioned user
        const mentionedUser = m.message.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
        if (!mentionedUser) {
            return reply("Please mention a user whose character you want to check.");
        }

        // Define character traits
        const userChar = [
            "Sigma",
            "Generous",
            "Grumpy",
            "Overconfident",
            "Obedient",
            "Good",
            "Simp",
            "Kind",
            "Patient",
            "Pervert",
            "Cool",
            "Helpful",
            "Brilliant",
            "Sexy",
            "Hot",
            "Gorgeous",
            "Cute",
        ];

        // Randomly select a character trait
        const userCharacterSelection =
            userChar[Math.floor(Math.random() * userChar.length)];

        // Message to send
        const message = `Character of @${mentionedUser.split("@")[0]} is *${userCharacterSelection}* ğŸ”¥âš¡`;

        // Send the message with mentions
        await conn.sendMessage(from, {
            text: message,
            mentions: [mentionedUser],
        }, { quoted: m });

    } catch (e) {
        console.error("Error in character command:", e);
        reply("An error occurred while processing the command. Please try again.");
    }
});





cmd({
    pattern: "prefix",
    dontAddCommandList: true,
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

let gett = await get("PREFIX")
if(gett === q) return await reply("Allready Done")
await input("PREFIX", q)

await reply("*PREFIX updated: " + q + "*")

} catch (e) {
reply('*Error !!*')
l(e)
}
})




cmd({
    pattern: "textsend",
    desc: "text send to jid",
    category: "owner",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{


if(!isOwner) return reply("*_This is an owner cmd._*")
if(!m.quoted) return reply("*_Please reply a text msg._*")
if(!q) return reply("*_Please give me a jid to send this text._*")

await conn.sendMessage(q, { text : m.quoted.msg })

reply("*_Text send successful âœ…_*")

}catch(e){
console.log(e)
reply(`${e}`)
}
})












cmd({
    pattern: "fb2",
    desc: "To download facebook videos.",
    category: "download",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

  if (!args[0]) {
    return reply('*`Ïâ„“Ñ”Î±Ñ•Ñ” gÎ¹Î½Ñ” Î± Ï‰Î±Î¹â„“âˆ‚ Æ’Î±Â¢Ñ”Ğ²ÏƒÏƒĞº â„“Î¹Î·Ğº`*');
  }

  await m.react('ğŸ•’');
  let res;
  try {
    res = await igdl(args[0]);
  } catch (error) {
    return reply('*`Ñ”ÑÑÏƒÑ ÏƒĞ²Ñ‚Î±Î¹Î·Î¹Î·g âˆ‚Î±Ñ‚Î±.`*');
  }

  let result = res.data;
  if (!result || result.length === 0) {
    return reply('*`Î·Ïƒ ÑÑ”Ñ•Î±â„“Ñ‚ Æ’ÏƒÏ…Î·âˆ‚.`*');
  }

  let data;
  try {
    data = result.find(i => i.resolution === "720p (HD)") || result.find(i => i.resolution === "360p (SD)");
  } catch (error) {
    return reply('*`Ñ”ÑÑÏƒÑ âˆ‚Î±Ñ‚Î± â„“ÏƒÑ•Ñ•.`*');
  }

  if (!data) {
    return reply('*`Î·Ïƒ âˆ‚Î±Ñ‚Î± Æ’ÏƒÏ…Î·âˆ‚.`*');
  }

  await m.react('âœ…');
  let video = data.url;
  let dev = 'Â© 2024 King Hansa FB Downloader | Download with ease, cherish forever.'

  try {
    await conn.sendMessage(m.chat, { video: { url: video }, caption: dev, fileName: 'fb.mp4', mimetype: 'video/mp4' }, { quoted: m });
  } catch (error) {
    return reply('*`Ñ”ÑÑÏƒÑ âˆ‚ÏƒÏ‰Î·â„“ÏƒÎ±âˆ‚ Î½Î¹âˆ‚Ñ”Ïƒ.`*');
  await m.react('âŒ');
  }
}catch(e){
console.log(e)
  reply(`${e}`)
}
});





cmd({
  pattern: "updatecmd",
  react: "ğŸ§",
  desc: "Update commands.",
  category: "owner",
  filename: __filename
},
async (conn, mek, m, {
  from,
  quoted,
  body,
  isCmd,
  command,
  args,
  q,
  isGroup,
  sender,
  senderNumber,
  botNumber2,
  botNumber,
  pushname,
  isMe,
  isOwner,
  groupMetadata,
  groupName,
  participants,
  groupAdmins,
  isBotAdmins,
  isAdmins,
  reply
}) => {
  try {
    if (!isOwner) return reply("Only bot owners can use this command.");

    const pluginsDir = path.join(__dirname, '../plugins');
    const files = fs.readdirSync(pluginsDir);

    for (const file of files) {
      if (file.endsWith('.js')) {
        const filePath = path.join(pluginsDir, file);
        require(filePath);
        console.log(`Loaded ${file}`);
      }
    }

    reply("Commands updated successfully.ğŸ’—ğŸŒ");
  } catch (e) {
    console.log(e);
    reply(`Error updating commands: ${e.message}`);
  }
});





















cmd({
    pattern: "joinsup",
    react: "ğŸ›¸",
    alias: ["panel", "support", "request"],
    desc: "join support group ",
    category: "main",
    use: '.joinsup',
    filename: __filename
},

async(conn, mek, m, {from, l, quoted, body, isCmd, umarmd, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
    try {
        const inviteCode = 'H3SknBQ95on6r77Ho9k5VK';
        await conn.groupAcceptInvite(inviteCode);
        reply('Joined successfully!');

    } catch(e) {
        console.log(e);
        reply(`Error: ${e}`);
    }
});







cmd(
  {
    pattern: "gen",
    alias: ["genboy", "genimg"],
    desc: "Generate AI profile picture",
    category: "convert",
    react: "ğŸ–¼ï¸",
    filename: __filename,
  },
  async (conn, mek, m, { from, args, reply }) => {
    try {
      let prompt = args.join(" ");
      if (!prompt) return reply("âš ï¸ Please provide a prompt! (Example: `.genpfp Red flowers`)");

      let apiUrl = `https://manul-ofc-tech-api-1e5585f5ebef.herokuapp.com/fluxai?prompt=${encodeURIComponent(prompt)}`;
      let response = await axios.get(apiUrl, { responseType: "arraybuffer" });

      await conn.sendMessage(
        from,
        { image: response.data, caption: `ğŸ¨ *AI Generated Image for:* _${prompt}_` },
        { quoted: m }
      );

    } catch (e) {
      console.error("GenPFP Command Error:", e);
      reply(`âŒ Error: ${e.message}`);
    }
  }
);






cmd({
    pattern: "alive2",
    react: "ğŸ’",
    desc: "Check bot status",
    category: "main",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  async function createImage(url) {
    const { imageMessage } = await generateWAMessageContent({
      image: {
        url: "https://files.catbox.moe/za6ytm.jpg"
      }
    }, {
      upload: conn.waUploadToServer
    });
    return imageMessage;
  }

  let push = [{
    body: proto.Message.InteractiveMessage.Body.fromObject({
      text: `âœ¨ Bot is Online!`
    }),
    footer: proto.Message.InteractiveMessage.Footer.fromObject({
      text: config.FOOTER
    }),
    header: proto.Message.InteractiveMessage.Header.fromObject({
      title: 'Hello ' + pushname,
      hasMediaAttachment: true,
      imageMessage: await createImage()
    }),
    nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({
      buttons: [{
        "name": "quick_reply",
        "buttonParamsJson": "{\"display_text\":\"Menu\",\"id\":\".menu\"}"
      }]
    })
  }];

  const msg = generateWAMessageFromContent(m.chat, {
    viewOnceMessage: {
      message: {
        messageContextInfo: {
          deviceListMetadata: {},
          deviceListMetadataVersion: 2
        },
        interactiveMessage: proto.Message.InteractiveMessage.fromObject({
          body: proto.Message.InteractiveMessage.Body.create({
            text: 'ğŸŒŸ Bot Status Check'
          }),
          footer: proto.Message.InteractiveMessage.Footer.create({
            text: config.FOOTER
          }),
          header: proto.Message.InteractiveMessage.Header.create({
            hasMediaAttachment: false
          }),
          carouselMessage: proto.Message.InteractiveMessage.CarouselMessage.fromObject({
            cards: [...push]
          })
        })
      }
    }
  }, {});

  await conn.relayMessage(m.chat, msg.message, {
    messageId: msg.key.id
  });

}catch(e){
console.log(e)
reply(`${e}`)
}
})












cmd({
    pattern: "pin",
    react: "ğŸ˜Œ",
    desc: "downlod images",
    category: "downlod",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  if (!q) return reply(`Please give me song name ?`);
  async function createImage(url) {
    const { imageMessage } = await generateWAMessageContent({
      image: {
        url
      }
    }, {
      upload: conn.waUploadToServer
    });
    return imageMessage;
  }

  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }
  let push = [];
  let { data } = await axios.get(`https://allstars-apis.vercel.app/pinterest?search=${q}`);
  let res = data.data.map(v => v);
  shuffleArray(res); // Mengacak array
  let ult = res.splice(0, 10); // Mengambil 10 gambar pertama dari array yang sudah diacak
  let i = 1;
  for (let pus of ult) {
    push.push({
      body: proto.Message.InteractiveMessage.Body.fromObject({
        text: `Images - ${i++}`
      }),
      footer: proto.Message.InteractiveMessage.Footer.fromObject({
        text: config.FOOTER
      }),
      header: proto.Message.InteractiveMessage.Header.fromObject({
        title: 'Hello ' + pushname,
        hasMediaAttachment: true,
        imageMessage: await createImage(pus)
      }),
      nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({
            buttons: [
              {
                "name": "single_select",
                "buttonParamsJson": "{\"title\":\"title\",\"sections\":[{\"title\":\"title\",\"highlight_label\":\"label\",\"rows\":[{\"header\":\"header\",\"title\":\"title\",\"description\":\"description\",\"id\":\"id\"},{\"header\":\"header\",\"title\":\"title\",\"description\":\"description\",\"id\":\"id\"}]}]}"
              },
              {
                "name": "quick_reply",
                "buttonParamsJson": "{\"display_text\":\"quick_reply\",\"id\":\"message\"}"
              },
              {
                 "name": "cta_url",
                 "buttonParamsJson": "{\"display_text\":\"url\",\"url\":\"https://www.google.com\",\"merchant_url\":\"https://www.google.com\"}"
              },
              {
                 "name": "cta_call",
                 "buttonParamsJson": "{\"display_text\":\"call\",\"id\":\"message\"}"
              },
              {
                 "name": "cta_copy",
                 "buttonParamsJson": "{\"display_text\":\"copy\",\"id\":\"123456789\",\"copy_code\":\"message\"}"
              },
              {
                 "name": "cta_reminder",
                 "buttonParamsJson": "{\"display_text\":\"cta_reminder\",\"id\":\"message\"}"
              },
              {
                 "name": "cta_cancel_reminder",
                 "buttonParamsJson": "{\"display_text\":\"cta_cancel_reminder\",\"id\":\"message\"}"
              },
              {
                 "name": "address_message",
                 "buttonParamsJson": "{\"display_text\":\"address_message\",\"id\":\"message\"}"
              },
              {
                 "name": "send_location",
                 "buttonParamsJson": ""
              }
           ]
      })
    });
  }
  const msg = generateWAMessageFromContent(m.chat, {
    viewOnceMessage: {
      message: {
        messageContextInfo: {
          deviceListMetadata: {},
          deviceListMetadataVersion: 2
        },
        interactiveMessage: proto.Message.InteractiveMessage.fromObject({
          body: proto.Message.InteractiveMessage.Body.create({
            text: 'Hellow how are you baby !'
          }),
          footer: proto.Message.InteractiveMessage.Footer.create({
            text: config.FOOTER
          }),
          header: proto.Message.InteractiveMessage.Header.create({
            hasMediaAttachment: false
          }),
          carouselMessage: proto.Message.InteractiveMessage.CarouselMessage.fromObject({
            cards: [
              ...push
            ]
          })
        })
      }
    }
  }, {});
  await conn.relayMessage(m.chat, msg.message, {
    messageId: msg.key.id
  });

}catch(e){
console.log(e)
reply(`${e}`)
}
})



















cmd({
  on: "body"
},
async (conn,mek, m, { from, body, isGroup, isAdmins, isBotAdmins, reply, sender }) => {
    try {

        const badWords = ["wtf", "mia","à¶´à·œà¶±à·Šà¶±à¶ºà·","à·„à·à¶¸à·’à¶±à·™à¶±à·€à·","à¶šà·à¶»à·’à¶ºà·", "à·„à·”à¶­à·Šà¶­à·", "à·„à·”à¶­à·Šà¶­à·","à¶´à¶šà¶ºà·","fuck","sex","huththa","pakaya","ponnaya","hutto","kariya","pakaya","hukapan","hukanna","hutto","xvdl","hutto","Hukapamm","lol"]
        if (!isGroup || isAdmins || !isBotAdmins) return; 

        const lowerCaseMessage = body.toLowerCase();
        const containsBadWord = badWords.some(word => lowerCaseMessage.includes(word));

        if (containsBadWord & config.ANTI_BAD === 'true') {
          await conn.sendMessage(from, { delete: mek.key }, { quoted: mek });
          await conn.sendMessage(from, { text: "âš ï¸BAD WORDS NOT ALLOWEDâš ï¸ " }, { quoted: mek });
          await conn.groupParticipantsUpdate(from, [sender], 'remove');
        }
    } catch (error) {
        console.error(error)
        reply("An error occurred while processing the message.")
    }
})
const linkPatterns = [
    /https?:\/\/(?:chat\.whatsapp\.com|wa\.me)\/\S+/gi,   
    /https?:\/\/(?:t\.me|telegram\.me)\/\S+/gi,           
    /https?:\/\/(?:www\.)?linkedin\.com\/\S+/gi,         
    /https?:\/\/(?:www\.)?snapchat\.com\/\S+/gi,         
    /https?:\/\/(?:www\.)?pinterest\.com\/\S+/gi,         
    /https?:\/\/(?:www\.)?reddit\.com\/\S+/gi,            
    /https?:\/\/ngl\/\S+/gi,                             
    /https?:\/\/(?:www\.)?discord\.com\/\S+/gi,           
    /https?:\/\/(?:www\.)?twitch\.tv\/\S+/gi,             
    /https?:\/\/(?:www\.)?vimeo\.com\/\S+/gi,            
    /https?:\/\/(?:www\.)?dailymotion\.com\/\S+/gi,      
    /https?:\/\/(?:www\.)?medium\.com\/\S+/gi,

];

cmd({
    on: "body"
}, async (conn, mek, m, { from, body, sender, isGroup, isAdmins, isBotAdmins, reply }) => {
    try {
        if (!isGroup || isAdmins || !isBotAdmins) return; // Skip if not in group, or sender is admin, or bot is not admin

        const containsLink = linkPatterns.some(pattern => pattern.test(body));

        if (containsLink && config.ANTI_LINK === 'true') {
            // Delete the message
            await conn.sendMessage(from, { delete: mek.key }, { quoted: mek });

            // Warn the user
            await conn.sendMessage(from, { text: `âš ï¸ Links are not allowed in this group.\n@${sender.split('@')[0]} has been removed. ğŸš«`, mentions: [sender] }, { quoted: mek });

             // Remove the user from the group
            await conn.groupParticipantsUpdate(from, [sender], 'remove');
        }
    } catch (error) {
        console.error(error);
        reply("An error occurred while processing the message.");
    }
});








cmd({ 
    pattern: "movie", 
    alias: ["film", "cinema"], 
    react: "ğŸ¬", 
    desc: "Search and Download Movies with Sinhala Subtitles", 
    category: "download", 
    use: '.movie < Movie Name >', 
    filename: __filename 
}, async (conn, mek, m, { from, prefix, quoted, q, reply }) => { 
    try { 
        if (!q) return await reply("âš ï¸ Please provide a movie name!");

        // Search for the movie
        let searchUrl = `https://omindu-api.up.railway.app/api/sinhalasub/search?query=${encodeURIComponent(q)}`;
        let searchResponse = await fetch(searchUrl);
        let searchData = await searchResponse.json();

        if (!searchData.results.movies || searchData.results.movies.length < 1) 
            return reply("âŒ No movies found!");

        let movie = searchData.results.movies[0];

        // Get download links
        let downloadUrl = `https://omindu-api.up.railway.app/api/sinhalasub/download?url=${encodeURIComponent(movie.link)}`;
        let downloadResponse = await fetch(downloadUrl);
        let downloadData = await downloadResponse.json();

        let movieInfo = downloadData.info;
        let dlLinks = downloadData.dl_links;

        let movieMsg = `â•­â”â”â”ã€” *ğŸŒŸ DIDULA MD V2 ğŸŒŸ* ã€•â”â”â”â”ˆâŠ·
â”ƒâ–¸â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ–¸â”ƒ ğŸ¬ *MOVIE DOWNLOADER*
â”ƒâ–¸â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·Â·Â·
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•­â”â”ââ”âª¼
â”‡ğŸ“Œ *Title:* ${movieInfo.title}
â”‡ğŸ“… *Release Date:* ${movieInfo.release_date}
â”‡â±ï¸ *Runtime:* ${movieInfo.runtime}
â”‡â­ *TMDB Rating:* ${movieInfo.tmdb_Rating}
â”‡ğŸ­ *Genres:* ${movieInfo.genres.join(", ")}
â”‡ğŸ¬ *Director:* ${movieInfo.director.name}
â•°â”â”â‘â”âª¼

ğŸ“¥ *Download Links:*

*Server 1:*
${dlLinks.server_01.map(link => `â–¢ ${link.quality} (${link.size})\n${link.link}`).join('\n\n')}

*Telegram:*
${dlLinks.telagram.map(link => `â–¢ ${link.quality} (${link.size})\n${link.link}`).join('\n\n')}

*Server 2:*
${dlLinks.server_02.map(link => `â–¢ ${link.quality} (${link.size})\n${link.link}`).join('\n\n')}

*Server 3:*
${dlLinks.server_03.map(link => `â–¢ ${link.quality} (${link.size})\n${link.link}`).join('\n\n')}

*Type . dl <download link> for download movie ğŸ’—ğŸ˜š*

*ğŸ’« Quality Movie Downloader By Didula MD V2*`;

        await conn.sendMessage(from, { 
            image: { url: movieInfo.poster }, 
            caption: movieMsg 
        }, { quoted: mek });

    } catch (e) {
        console.log(e);
        reply("âŒ An error occurred. Please try again later.");
    }
});


cmd({
    pattern: "itnnews",
    desc: "Get the latest ITN news headlines or details of a given link.",
    category: "news",
    react: "ğŸ“°",
    filename: __filename
},
async (conn, mek, m, { from, reply, q }) => {
    try {
        const rssFeedUrl = 'https://www.itnnews.lk/feed/';
        const response = await axios.get(rssFeedUrl);
        const xmlData = response.data;

        const parser = new xml2js.Parser();
        const result = await parser.parseStringPromise(xmlData);

        const newsItems = result.rss.channel[0].item.map(item => ({
            title: item.title[0],
            link: item.link[0],
            description: item.description[0],
            pubDate: item.pubDate[0]
        }));

        // User à¶‘à¶šà¶§ link à¶‘à¶šà¶šà·Š à¶¯à·“à¶½à· search à¶šà¶»à·œà¶­à·Š
        if (q && q.startsWith("https://www.itnnews.lk/")) {
            const article = newsItems.find(news => news.link === q.trim());
            if (!article) return reply("âŒ Sorry, this news article was not found in the latest updates!");

            let articleText = `*Didula MD V2 - ğŸ“° ITN News Details:*\n\n`;
            articleText += `ğŸ“Œ *${article.title}*\n`;
            articleText += `ğŸ“… _${article.pubDate}_\n`;
            articleText += `ğŸ“– ${article.description}\n`;
            articleText += `ğŸ”— ${article.link}\n\n> á´©Ê€á´á´Šá´‡á´„á´›êœ± á´êœ° á´…Éªá´…á´œÊŸá´€ Ê€á´€êœ±Êœá´Éªá´‹á´€`;

            return reply(articleText);
        }

        // User à¶‘à¶š link à¶‘à¶šà¶šà·Š à¶¯à·“à¶½à· à¶±à·à¶­à·Šà¶±à¶¸à·Š Latest 5 news return à¶šà¶»à¶±à·€à·
        let newsText = `*ğŸ“° ITN Latest News:*\n\n`;
        newsItems.slice(0, 5).forEach((news, index) => {
            newsText += `ğŸ“Œ *${index + 1}.* *${news.title}*\n`;
            newsText += `ğŸ“… _${news.pubDate}_\n`;
            newsText += `ğŸ”— ${news.link}\n\n\n> á´©Ê€á´á´Šá´‡á´„á´›êœ± á´êœ° á´…Éªá´…á´œÊŸá´€ Ê€á´€êœ±Êœá´Éªá´‹á´€`;
        });

        reply(newsText);
    } catch (error) {
        console.error("Error fetching ITN News:", error);
        reply("âŒ Could not fetch ITN news. Please try again later.");
    }
});














cmd({
    pattern: "pornhub",
    alias: ["ph"],
    react: "ğŸ¥",
    desc: "download xVideo",
    category: "download",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!q) return reply("*âš ï¸ Please provide a video title or URL*\n\n*Example:* .xvideo Nicolette");

        const query = String(q);
        const searchResponse = await axios.get(`https://ipa-oya.vercel.app/api/ph?q=${encodeURIComponent(query)}`);

        const deta = searchResponse.data;
        const videoUrl = deta.url;

        let desc = `ğŸ¥ *Didula MD V2 - Now Downloading:* ${deta.title}

â³ *Please wait, processing your request...*`;

        await conn.sendMessage(from, { 
            image: { url: deta.image }, 
            caption: desc 
        }, { quoted: mek }).catch(() => reply("âŒ Error sending thumbnail"));

        try {
            const downloadResponse = await axios.get(`https://ipa-oya.vercel.app/api/phdl?q=${encodeURIComponent(videoUrl)}`);
            const downloadUrls = downloadResponse.data;

            if (!downloadUrls || downloadUrls.length === 0) {
                return reply("âŒ No download links found.");
            }

            let downloadMessage = "ğŸ¥ *Didula MD V2 Successfully Downloaded!*\n\nAvailable Resolutions:\n";
            downloadUrls.forEach((video) => {
                downloadMessage += `- ${video.resolution}p: ${video.download_url}\n`;
            });

            // Send the first download link as a video message
            const firstDownloadUrl = downloadUrls[0].download_url;
            await conn.sendMessage(from, { 
                video: { url: firstDownloadUrl }, 
                caption: downloadMessage 
            }, { quoted: mek });

        } catch (error) {
            reply("âŒ Error fetching download links: " + error.message);
        }

    } catch (e) {
        console.log(e);
        reply(`âŒ Error: ${e.message}`);
    }
});


cmd({
    pattern: "xvideo",
    alias: ["xvideo2"],
    react: "ğŸ¥",
    desc: "download",
    category: "download",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!q) return reply("*âš ï¸ Please provide a video title or URL*\n\n*Example:* .xvideo My MILF Secretary Love");

        const query = String(q);
        const searchResponse = await axios.get(`https://api.giftedtech.my.id/api/search/xvideossearch?apikey=gifted&query=${encodeURIComponent(query)}`);

        if (!searchResponse.data.results || !searchResponse.data.results.length) {
            return reply("âŒ No results found! Please try another search.");
        }

        const deta = searchResponse.data.results[0];
        const videoUrl = deta.url;

        let desc = `ğŸ¥ *Didula MD V2 - Now Downloading:* ${deta.title}

â±ï¸ *Duration:* ${deta.duration}
ğŸ‘ï¸ *Views:* ${deta.views || 'N/A'}
ğŸ“… *Quality:* ${deta.quality || 'N/A'}

â³ *Please wait, processing your request...*`;

        await conn.sendMessage(from, { 
            image: { url: deta.thumb }, 
            caption: desc 
        }, { quoted: mek }).catch(() => reply("âŒ Error sending thumbnail"));

        try {
            const downloadResponse = await axios.get(`https://api.giftedtech.my.id/api/download/xvideosdl?apikey=gifted&url=${encodeURIComponent(videoUrl)}`);

            const downloadUrl = downloadResponse.data.result.download_url;

            await conn.sendMessage(from, { 
                video: { url: downloadUrl }, 
                mimetype: "video/mp4", 
                caption: "ğŸ¥ *Didula MD V2 Successfully Downloaded!*" 
            }, { quoted: mek });

        } catch (error) {
            reply("âŒ Error downloading video: " + error.message);
        }

    } catch (e) {
        console.log(e);
        reply(`âŒ Error: ${e.message}`);
    }
});




cmd({
    pattern: "hirucheck",
    alias: ["hirunews","newshiru","hirulk"],
    react: "â­",
    category: "search",
    desc: "Fetch the latest news from the SUHAS API in Hiru API.",
    use: "",
    filename: __filename,
},
    async (conn, mek, m, {
        from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber,
        botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName,
        participants, groupAdmins, isBotAdmins, isAdmins, reply
    }) => {
        try {
            const apiUrl = `https://suhas-bro-apii.vercel.app/hiru`;
//Dont Change This API Key
            const response = await axios.get(apiUrl);
            const data = response.data;

            if (!data || !data.newsURL || !data.title || !data.image || !data.text) {
                return reply(`*No News Available At This Moment* â—`);
            }

            const { newsURL, title, image, text, Power } = data;

            let newsInfo = "ğƒğ¢ğğ®ğ¥ğš ğŒğƒ ğ•ğŸ ğğğ°ğ¬ ğŸ“°\n\n";
            newsInfo += `âœ¨ *Title*: ${title}\n\n`;
            newsInfo += `ğŸ“‘ *Description*:\n${text}\n\n`;
            newsInfo += `â›“ï¸â€ğŸ’¥ *Url*: www.hirunews.lk\n\n`;
            newsInfo += `> *á´©Ê€á´á´Šá´‡á´„á´›êœ± á´êœ° á´…Éªá´…á´œÊŸá´€ Ê€á´€êœ±Êœá´Éªá´‹á´€*`;

            if (image) {
                await conn.sendMessage(m.chat, {
                    image: { url: image },
                    caption: newsInfo,
                }, { quoted: m });
            } else {
                await conn.sendMessage(m.chat, { text: newsInfo }, { quoted: m });
            }

        } catch (error) {
            console.error(error);
            reply(`*An Error Occurred While Fetching News At This Moment* â—`);
        }
    }
);






cmd({
    pattern: "happy",
    desc: "Displays a dynamic edit msg for fun.",
    category: "other",
    react: "ğŸ˜‚",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ˜‚' });
        const emojiMessages = [
            "ğŸ˜ƒ", "ğŸ˜„", "ğŸ˜", "ğŸ˜Š", "ğŸ˜", "ğŸ¥³",
            "ğŸ˜¸", "ğŸ˜¹", "ğŸŒ", "ğŸŒˆ", "ğŸ˜ƒ", "ğŸ˜„",
            "ğŸ˜", "ğŸ˜Š", "ğŸ˜", "ğŸ¥³", "ğŸ˜¸", "ğŸ˜¹",
            "ğŸŒ", "ğŸŒˆ", "ğŸ˜ƒ", "ğŸ˜„", "ğŸ˜", "ğŸ˜Š"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "heart",
    desc: "Displays a dynamic edit msg for fun.",
    category: "other",
    react: "â¤ï¸",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ–¤' });
        const emojiMessages = [
            "ğŸ’–", "ğŸ’—", "ğŸ’•", "ğŸ©·", "ğŸ’›", "ğŸ’š",
            "ğŸ©µ", "ğŸ’™", "ğŸ’œ", "ğŸ–¤", "ğŸ©¶", "ğŸ¤",
            "ğŸ¤", "â¤ï¸â€ğŸ”¥", "ğŸ’", "ğŸ’“", "ğŸ’˜", "ğŸ’",
            "â™¥ï¸", "ğŸ’Ÿ", "â¤ï¸â€ğŸ©¹", "â¤ï¸"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "angry",
    desc: "Displays a dynamic edit msg for fun.",
    category: "other",
    react: "ğŸ¤¡",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ‘½' });
        const emojiMessages = [
            "ğŸ˜¡", "ğŸ˜ ", "ğŸ¤¬", "ğŸ˜¤", "ğŸ˜¾", "ğŸ˜¡",
            "ğŸ˜ ", "ğŸ¤¬", "ğŸ˜¤", "ğŸ˜¾"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "sad",
    desc: "Displays a dynamic edit msg for fun.",
    category: "other",
    react: "ğŸ˜¶",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ˜”' });
        const emojiMessages = [
            "ğŸ¥º", "ğŸ˜Ÿ", "ğŸ˜•", "ğŸ˜–", "ğŸ˜«", "ğŸ™",
            "ğŸ˜©", "ğŸ˜¥", "ğŸ˜“", "ğŸ˜ª", "ğŸ˜¢", "ğŸ˜”",
            "ğŸ˜", "ğŸ˜­", "ğŸ’”", "ğŸ˜­", "ğŸ˜¿"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "shy",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ğŸ§",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ§' });
        const emojiMessages = [
            "ğŸ˜³", "ğŸ˜Š", "ğŸ˜¶", "ğŸ™ˆ", "ğŸ™Š",
            "ğŸ˜³", "ğŸ˜Š", "ğŸ˜¶", "ğŸ™ˆ", "ğŸ™Š"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "moon",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ğŸŒš",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸŒ' });
        const emojiMessages = [
            "ğŸŒ—", "ğŸŒ˜", "ğŸŒ‘", "ğŸŒ’", "ğŸŒ“", "ğŸŒ”",
            "ğŸŒ•", "ğŸŒ–", "ğŸŒ—", "ğŸŒ˜", "ğŸŒ‘", "ğŸŒ’",
            "ğŸŒ“", "ğŸŒ”", "ğŸŒ•", "ğŸŒ–", "ğŸŒ—", "ğŸŒ˜",
            "ğŸŒ‘", "ğŸŒ’", "ğŸŒ“", "ğŸŒ”", "ğŸŒ•", "ğŸŒ–",
            "ğŸŒ—", "ğŸŒ˜", "ğŸŒ‘", "ğŸŒ’", "ğŸŒ“", "ğŸŒ”",
            "ğŸŒ•", "ğŸŒ–", "ğŸŒğŸŒš"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "confused",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ğŸ¤”",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ¤”' });
        const emojiMessages = [
            "ğŸ˜•", "ğŸ˜Ÿ", "ğŸ˜µ", "ğŸ¤”", "ğŸ˜–", 
            "ğŸ˜²", "ğŸ˜¦", "ğŸ¤·", "ğŸ¤·â€â™‚ï¸", "ğŸ¤·â€â™€ï¸"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "hot",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ğŸ’‹",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ’‹' });
        const emojiMessages = [
            "ğŸ¥µ", "â¤ï¸", "ğŸ’‹", "ğŸ˜«", "ğŸ¤¤", 
            "ğŸ˜‹", "ğŸ¥µ", "ğŸ¥¶", "ğŸ™Š", "ğŸ˜»", 
            "ğŸ™ˆ", "ğŸ’‹", "ğŸ«‚", "ğŸ«€", "ğŸ‘…", 
            "ğŸ‘„", "ğŸ’‹"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "didula",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ğŸ—¿",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'Didula-AIğŸ—¿' });

        // Define the ASCII art messages
        const asciiMessages = [
            "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â â ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €â €â €â €     â¢³â¡€â €â¡â €â €â €   â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €â €â €  â €    â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²     â£¿  â£¸   Nikal   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €â €      â£¿  â¢¹â €          â¡‡\n  â ™â¢¿â£¯â „â €â €â €__â €   â €   â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â â €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â â ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €â €â €â €  â €  â¢³â¡€â €â¡â €â €â €   â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €â €â €       â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²     â£¿  â£¸   Lavde   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €â €      â£¿  â¢¹â €          â¡‡\n  â ™â¢¿â£¯â „â €â €|__|â €â €   â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â â €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â â ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €     â €   â¢³â¡€â €â¡â €â €    â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €â €â €â €      â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²    â£¿  â£¸   Pehli   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €â €     â£¿  â¢¹â €           â¡‡\n  â ™â¢¿â£¯â „â €â €(P)â €â €     â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â â €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â â ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €     â €   â¢³â¡€â €â¡â €â €    â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €   â €     â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²    â£¿  â£¸  Fursat  â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €        â£¿  â¢¹â €          â¡‡\n  â ™â¢¿â£¯â „â €â €â €__ â €  â €   â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â â €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â â ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €â €â €â €      â¢³â¡€â €â¡â €â €    â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €â € â €      â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²    â£¿  â£¸  Meeee   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €â €       â£¿  â¢¹â €          â¡‡\n  â ™â¢¿â£¯â „â €â €|__| â €    â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â â €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â â ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €â €â €   â €  â €â¢³â¡€â €â¡â €â €       â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €  â €       â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²   â£¿  â£¸   Nikal   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €       â£¿  â¢¹â €           â¡‡\n  â ™â¢¿â£¯â „â €â €loduâ €â €   â¡¿ â €â¡‡â €â €â €â €   â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €  â¡´â ƒâ €   â ˜â ¤â£„â£ â â €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €"
        ];

        // Send the initial loading message
        for (const asciiMessage of asciiMessages) {
            await new Promise(resolve => setTimeout(resolve, 500)); // Delay for 500ms second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: asciiMessage,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

// > JawadTechX 







cmd({
    pattern: "owner",
    desc: "To check ping",
    category: "main",
    react: "ğŸ‘¤",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

const vcard = 'BEGIN:VCARD\n'
            + 'VERSION:3.0\n' 
            + 'FN:Didula Rashmika\n'
            + 'ORG:Didula MD V2;\n'
            + 'TEL;type=CELL;type=VOICE;waid=94741671668:+94 741 671 668\n'
            + 'TEL;type=CELL;type=VOICE;waid=94771820962:+94 771 820 962\n'
            + 'END:VCARD'

await conn.sendMessage(from, { 
    contacts: { 
        displayName: 'Didula Rashmika', 
        contacts: [{ vcard }] 
    }
},{quoted:mek})

await conn.sendMessage(from,{image:{url: 'https://files.catbox.moe/za6ytm.jpg'},caption: `*ğŸ‘¤ Didula MD V2 Owner Details*\n\n*ğŸ‘¨â€ğŸ’» Owner Name:* Didula Rashmika\n*ğŸ“± Owner Number:* wa.me/94741671668\n*ğŸ“± Owner Number:* wa.me/94771820962\n\n\n*ğŸ’« Thanks For Using Didula MD V2*`},{quoted:mek})

} catch (e) {
    reply(e)
    }
})





cmd({
    pattern: "repo",
    desc: "repo the bot",
    react: "ğŸ“¡",
    category: "main",
    filename: __filename
},
async(conn, mek, m, {from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
    try {
        let dec = `*DIDULA MD V2 NEW UPDATEâœ…*

*â­• REPO URL*
\`\`\`https://github.com/itsme-didulabot/Didula-MD-V2\`\`\`

*â­• GET SESSION ID*
\`\`\`https://prabath-md-pair-web-v2-slk.koyeb.app/pair\`\`\`

*â­• HEROKU DEPLOY*
\`\`\`https://dashboard.heroku.com/new-app?template=https://github.com/itsme-didulabot/Didula-MD-V2\`\`\`

*Deploy Video âœ…*

https://youtu.be/AtjXpHEwyKg?si=iLIxkkr4ujCu72cj


SPECIAL FEATURES ğŸ‘€

> Chanel working
> Heart React
> Anti Bug Message
> Anti Bad/Bot/Link/Call
> AI Chat
> Auto Status Seen React and Reply
> Anti Once View
> Send Status to reply
> Anti Delete
> Commands 100+

*AUTO PLUGIN UPDATE*

ğŸ“¥FOLLOW FOR UPDATE
https://whatsapp.com/channel/0029VaqqF4GDTkJwKruLSK2f`;

        await conn.sendMessage(from, {
            image: {url: 'https://files.catbox.moe/za6ytm.jpg'},
            caption: dec
        }, {quoted: mek});

    } catch(e) {
        console.log(e);
        reply(`${e}`);
    }
});